%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{article}

%% Improve hyphenation
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Thread Injection and Continuation Injection}
\author{Daniel Sagenschneider}
\date{}
\maketitle

\abstract{}
The Thread Injection and Continuation Injection patterns provide implementing
algorithms for the participants of the Proactor pattern to enable Inversion of
Control for executing threads and execution order of operations.  These patterns
combined with Dependency Injection provide a complete Inversion of Control
pattern.

\section{Introduction}

The Proactor pattern \cite{proactor} is used as the basis of popular modern web
servers \footnote{Apache, Microsoft IIS, Nginx and JEE identified from the
Netcraft November 2012 survey.  Google Web Server is also identified as
popular.} to dispatch requests asynchronously to request handlers (Asynchronous
Operations).

The disadvantage of the Proactor pattern is that the ``Asynchronous Operation
Processor must be designed carefully to support prioritization and cancellation
of Asynchronous Operations'' \cite{proactor}.  When not relying on the Operation
System's asynchronous I/O, the Proactor pattern does suggest using a single
thread pool to execute the asynchronous operations.  Performance analysis of web
servers identifies the importance of tuning this prioritization
\cite{tuning-important,low-server-footprint,tuning-os-important}.  The Thread
Injection pattern presented in this paper focuses on addressing prioritization
of Asynchronous Operations by using multiple thread pools.

The Asynchronous Operation API has also become a single standard interface to
enable servicing dynamic web page content.  The discussion of the Proactor
pattern focused on web servers providing static content with developers
implementing the Proactor Initiator.  Popular web servers however provide
dynamic web page content via developers implementing Asynchronous Operations to
service a request.  To enable portable implementations the Asynchronous
Operation interface has been standardised \footnote{CGI/FastCGI with for
example PHP scripts, Microsoft's HTTP.sys/WAS and JEE Servlets}.

The design of the Proactor pattern was to enable using many Asynchronous
Operations in servicing a HTTP request.  For the popular Web Servers
standardising of the Asynchronous Operation interface however has focused on the
Proactor benefit of simplification of application synchronization by allowing
only one Asynchronous Operation to synchronously service the entire dynamic web
page content \footnote{JEE Servlet 3.x AsyncContext is enabling implementing
code for the Proactor Initiator however this requires the developer to be aware
of thread synchronization complexities}.  The Continuation Injection pattern
presented focuses on addressing this by allowing multiple Asynchronous
Operations to be used for dynamic web page content. It also provides the means
for cancellation of Asynchronous Operations.


\section{A Motivating Example}

A motivating example for the Thread Injection and Continuation Injection
patterns is servicing dynamic web content.  A typical dynamic web request
servicing may use both cached/static content and data retrieved from a database.

Due to the standardising of the Asynchronous Operation interface, requests
involving no I/O or heavy I/O are serviced by the same pool of threads.
If for example the database I/O becomes slow causing all threads to block,
requests requiring only cached content are not prioritized as they are starved
of a thread.

Also for requests requiring only in memory cached content, popular modern web
servers continue to use a separate thread and incurs the cost of one or more
thread context switches.  If the web server knew further details about the
nature of each Asynchronous Operation, it should allow the Asynchronous
Operation to safely borrow the thread to reduce thread context switching.

Table \ref{tab:example_request_operations} lists the operations for servicing an
example HTTP request.  The operations executed differ based on whether there is
a cache hit or miss.  Ideally, as explained above, all operations up to and
including the \texttt{Retrieve data from cache} should be borrowing the thread
to avoid a thread context switch.  A separate thread should then only be used if
the \texttt{Retrieve data from database} operation needs to be executed.  The
remaining operations should then again be borrowing the thread to avoid thread
context switching.

\begin{table}[!h]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l||l}
\hline
\bfseries Cache Miss Operations & \bfseries Cache Hit Operations & \bfseries Dependencies \\
\hline\hline
Read data from socket & Read data from socket & Selector, Socket \\
\hline
Parse HTTP request & Parse HTTP request & Data read \\
\hline
Dispatch HTTP request & Dispatch HTTP request & HTTP request \\
\hline
Validate client data & Validate client data & HTTP request \\
\hline
Retrieve data from cache & Retrieve data from cache & Client data, \\
(cache miss) & (cache hit) & Cache \\
\hline
Retrieve data from database & - & Client data, \\
 & & Database connection \\
\hline
Render HTTP response & Render HTTP response & Database data \\
\hline
Write HTTP response & Write HTTP response & HTTP response, \\ 
 & & Socket \\
\hline
\end{tabular}
\caption{Example operations for servicing a HTTP request from database and caches. The dependencies of each operation are also listed.}
\label{tab:example_request_operations}
\end{table}

The ability to string discrete operations together and choose the executing
thread for each operation (both externally to the operation) is the focus of the
Thread Injection and Continuation Injection patterns.


\section{Dependency Injection}

The naming of the Thread Injection and Continuation Injection pattern is because
of their close association to the Dependency Injection pattern.

The Dependency Injection pattern enables constructing objects using extrinsic
dependency information to load dependencies without the need of the client
object requiring awareness of the dependencies \cite{ioc}.  This allows
implementations to be swapped without syntatic changes.

The Dependency Injection pattern therefore enables:
\begin{enumerate}
  \item A single interface for multiple implementations
  \item Meta-data about dependencies required for the implementation
  \item Means to provide one or more differing objects to the implementation
\end{enumerate}

These properties of the Dependency Injection pattern are important for the
patterns described:
\begin{itemize}
  \item Single interface is necessary for the Asynchronous Operations.
  \item Meta-data about dependencies provides Thread Injection the necessary information for dispatching Asynchronous Operations to the appropriate thread pool.
  \item Continuations encapsulating the Proactor Completion Handlers/Dispatchers can be dependency injected into Asynchronous Operations.
\end{itemize}


\section{Thread Injection}

The Thread Injection pattern addresses both the implementation of the
Asynchronous Operation Processor and providing a standard interface for the
Asynchronous Operation to provide prioritiziation information.

As already mentioned, the Proactor pattern specifies that the Asynchronous
Operation API must be both portable and flexible.  While this applies to the API
between the Proactor Initiator and Asynchronous Operation, it also must apply to
the API between the Asynchronous Operation and Asynchronous Operation Processor
to decouple them.  This will enable portable developer implementations of
Asynchronous Operations (such as generating dynamic web page content). 

For the Thread Injection pattern, all Asynchronous Operations are constructed
via extrinsic dependency management \cite{ioc} to allow a standard interface.
The construction of the Asynchronous Operation is encapsulated in the depenency
management factory.  This enables both the interfaces to the Proactor Initiator
and Asynchronous Operation Processor to be standardised.

Standardising the interface between the Proactor Initiator and Asynchronous
Operation is not necessary for Thread Injection.  It is however necessary for
Continuation Injection discussed later in this paper.

The interface for the Asynchronous Operation is provided in Fig
\ref{fig:AO_interface_AOP}.

\begin{figure}[!h]
\begin{verbatim}
    interface DependencyInjectionFactory {
    
        Type[] getRequiredDependencyTypes(String operationId);
        
        AsynchronousOperation createOperation(String operationId);
    }

    interface AsynchronousOperation {
    
        void execute(AsynchronousOperationContext context);
        
        void cancel(Exception cause);
        
        String[] getContinuationIds();
    }
\end{verbatim}
\caption[Caption for Code]{Asynchronous Operation interface}
\label{fig:AO_interface_AOP}
\end{figure}

The \texttt{execute()} method is invoked by the thread of the chosen thread pool
to execute the implementation of the Asynchronous Operation.  The
\texttt{AsynchronousOperationContext} parameter and \texttt{getContinuationIds()}
method provides means for Continuation Injection explained later.


\subsection{Prioritizing Asynchronous Operations}

The prioritization provided by the Thread Injection pattern is achieved by using
the \texttt{getRequiredDependencyTypes(String operationId)} method to obtain the
extrinsic depenency management information \footnote{Dependency Injection
frameworks using qualification to identify dependencies of the same type may
return a type object containing both class and qualifier rather than just a
class.}.

The developer configures one or more thread pools responsible for Asynchronous
Operations with a particular type of dependency \footnote{Thread pools may be
associatied to more than one dependency type}.  The Asynchronous Operation is
then matched by its required dependency types to a Thread Pool responsible for
one or more of the dependency types. Table
\ref{tab:example_request_thread_pools} provides an example set of thread pools
for the motivating example.

\begin{table}[!h]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l||l}
\hline
\bfseries Thread Pool & \bfseries Dependency Type & \bfseries Asynchronous Operation \\
\hline\hline
Network & Selector & Read data from socket \\
\hline
Database & Database connection & Retrieve data from database \\
\hline
Default & - & Parse HTTP request, \\
& & Dispatch HTTP request, \\
& & Validate client data, \\ 
& & Retrieve data from cache, \\
& & Render HTTP response, \\
& & Write HTTP response \\
\hline
\end{tabular}
\caption{Example assigning of thread pool to Asynchronous Operations by dependency type}
\label{tab:example_request_thread_pools}
\end{table}

As a thread pool is configured for Asynchronous Operations with a
\texttt{Database connection}, the \texttt{Retrieve data from database} operation
is configured to be executed by its own thread pool.  As the \texttt{Database
connection} is only available via Dependency Injection, all Asynchronous
Operations requiring I/O with the database must depend on the \texttt{Database
connection} and subsequently are mapped to be executed by a thread from the
\texttt{Database} thread pool.  The remaining operations have their own thread
pools allowing them to continue to be executed even if the database I/O is
causing thread starvation within its own thread pool.

The Thread Injection pattern can therefore be considered a style of cohort
scheduling \cite{cohort} to group operations with similar dependencies (and
inferring from that similar functionality).  It however works at the application
scheduling level and allows use of any Operating System thread scheduling
algorithms.  Furthermore, tuning the thread pools (such as restricting number of
threads or changing the pool's thread nice values) allows prioritizing threads and
subsequently prioritizing Asynchronous Operations.

As the dependencies for each Asynchronous Operation is static, at application
start up time the Asynchronous Operation Processor may also preprocess the
mapping of Asynchronous Operations to Thread Pools to reduce runtime decision
overheads.  This pre-mapping of Asynchronous Operations may also provide
warnings where dependencies of an Asynchronous Operation may make it possible to
be mapped to multiple thread pools.  Different conflict mapping resolutions may
be employed, however ordering the thread pools and assigning based on first
match is a sufficiently adequate algorithm.

The result for the motivating examples is the the operations for servicing the
cached request can now be prioritized.  This can occur even if the database
driver has become non-responsive blocking all threads attempting to use a
database connection.

From the perspective of the Asynchronous Operation, the developer is now able to
configure which thread pool will execute each Asynchronous Operation.  This
effectively injects the thread for execution similar to injecting a dependency
for use.  Hence the name of the pattern, Thread Injection.


\subsection{Cancelling Asynchronous Operations}

The \texttt{cancel(Exception)} provides the means for the Asynchronous Operation
Processor to cancel the Asynchronous Operation.  Once invoked, the Asynchronous
Operation Processor may discard the Asynchronous Operation.

The implementaion of the \texttt{cancel(Exception)} is the responsibility of the
Asynchronous Operation as it will likely be specific to the operation's
implementation.  The Continuation Injection pattern explained later provides a
means to alleviate this from the Asynchronous Operation implementation.

As each thread pool is executing Asynchronous Operations for a particular
dependency (or set of dependencies), it allows for adaptive resource management
and admission control regarding the dependency \cite{seda}.  This enables both
the number of threads and dependencies to be dynamically altered to improve
throughput.  However when maximum throughput is reached, additional Asynchronous
Operations above this threshold can be cancelled.


\section{Continuation Injection}

Continuation Injection focuses on the algorithms implementing the Proactor pattern's
Proactive Initiator, Completion Handler and Completion Dispatcher participants
to enable multiple Asynchronous Operations to be utilised in servicing HTTP
requests.

The Continuation Injection relies on providing the
\texttt{AsynchronousOperationContext} (Fig \ref{fig:AOC_interface}) to the
Asynchronous Operations (Fig
\ref{fig:AO_interface_AOP}).  The \texttt{getDependency(\ldots)}
method provides retrieval of the extrinsically defined dependencies (Dependency
Injection).  The remaining methods are for Continuation Injection.

\begin{figure}[!h]
\begin{verbatim}
    interface AsynchronousOperationContext {
    
        Object getDependency(String dependencyId);
        
        Future doContinuation(String continuationId, 
                                Object parameter);
        
        void continueOperation();
    }
\end{verbatim}
\caption[Caption for Code]{Asynchronous Operation Context interface \footnotemark}
\label{fig:AOC_interface}
\end{figure}
\footnotetext{Integer identifiers may be used for fast array lookups rather than strings}

The \texttt{doContinuation(\ldots)} method triggers the Proactive Initiator to
undertake an Asynchronous Operation.  The Proactive Initiator is aware of the
possible continuations of the Asynchronous Operation via the
\texttt{getContinuationIds()} method (Fig \ref{fig:AO_interface_AOP}).  As the
continuation identifiers are static for each Asynchronous Operation, developer
configuration provides the mapping to the respective handling Asynchronous
Operation.  To ease debugging and better developer understanding of the
application, the configuration may be graphical where Asynchronous Operations
are nodes and continuation mappings are directed lines.

As the continuation is an asynchronous operation, it may use the returned
\texttt{Future} to determine when the sequence of triggered Asynchronous
Operations has completed \footnote{State is managed within the dependencies so
there is no need for a return value from the \texttt{Future}}.  This enables
process continuations \cite{process-continuation} to be spawned by repeatly
calling \texttt{doContinuation(\ldots)} to aid in resolving such issues as the
reverse 10K problem \cite{reverse-ten-k-problem}.

Furthermore as continuations result in Asynchronous Operations, they need not
only be invoked by Asynchronous Operations. Fig \ref{fig:DC_interface}
illustrates a possible interface that can be made available to dependencies to
invoke an Asynchronous Operation.  This enables dependencies to effectively
become Active Objects \cite{active-object} when necessary.

\begin{figure}[!h]
\begin{verbatim}
    interface DependencyContinuation {
            
        void doContinuation(Object parameter);
    }
\end{verbatim}
\caption[Caption for Code]{Dependency Context interface to invoke a continuation}
\label{fig:DC_interface}
\end{figure}

The \texttt{continueOperation()} method enables executing the current
Asynchronous Operation again.  The Asynchronous Operation Processor may be
implemented to defer execution of an Asynchronous Operation until invoked
continuations by the Asynchronous Operation or any of its dependencies are
completed.  This for example allows deferring executing the Asynchronous
Operation again until an Operating System asynchronous I/O operation completes -
a key aspect of the Proactor pattern.

Continuation Injection therefore enables stringing together multiple
Asynchronous Operations to service the HTTP request.  This can be considered a
form of continuation-passing style \cite{continuations} except that the
continuation is dependency injected rather than passed as a parameter.  The
added benefit of dependency injecting the continuation is that the Asynchronous
Operation is free to dependend on as many continuations as necessary.


\subsection{Initial Asynchronous Operation to service a HTTP request}

For web servers, URL continuations \cite{url-continuation} are used to invoke
the first Asynchronous Operation in the string.  Asynchronous Operations may be
associated to a URL by developer configuration.  This Asynchronous Operation
then becomes the first operation to be invoked for servicing a HTTP request for
that URL.  This configuration may be included in Continuation Injection graphical
configuration as an attribute of the Asynchronous Operation.

Providing identifiers to these Asynchronous Operations is also a convenient
means to ease maintenance of web pages.  Rather than embedding the URL in the
web page content, the Asynchronous Operation identifier is used.  When the page
is rendered for the client, the identifiers are replaced the with the actual
URLs.  This allows the URLs to be changed without needing to change web pages.


\subsection{Continuation for cancelling an Asynchronous Operation}

Cancelling the Asynchronous Operation by the Asynchronous Operation Processor is
handled by the Asynchronous Operation invoking a continuation.  On the
Asynchronous Operation Processor invoking the \texttt{cancel(Exception cause)}
method, the Asynchronous Operation will clean up any resources and then invoke a
continuation invoking an Asynchronous Operation for another thread pool.

Each Asynchronous Operation may specifically specify the continuation or a
default continuation may be configured across a set of Asynchronous Operations. 
The default continuation will be mapped to an Asynchronous Operation that
interrogates the \texttt{cause} and undertakes appropration further Asynchronous
Operations specific to the required application behaviour.


\section{Implicit Thread}

When using the Thread Injection and Continuation Injection pattern together,
implicit threads may be used to reduce thread context switching.

The continuation may borrow the thread of the invoking Asynchronous Operation if
it results in execution by the same thread pool.  The Proactor Pattern
stipulates that Asynchronous Operations ``are performed without borrowing the
application's thread of control'' \cite{proactor} and this is the focus of the
Reactor Pattern \cite{reactor}.  Rather than dispatching back to the same thread
pool the continued Asynchronous Operations may safely borrow the thread to avoid
the overhead of a thread context switch.

This same idea is also extended to the default thread pool for the Thread
Injection pattern.  For an Asynchronous Operation not requiring any dependencies
for dispatching to a specific thread pool, the Asynchronous Operation is deemed
cheaper to be executed by borrowing the thread than incurring the cost of a
thread context switch.

The borrowed thread is the implicit thread.  Like an implicit continuation that
executes the next operation \cite{continuations}, the implicit thread executes
the next operation unless a explicit thread is required.  This can result in the
Web Server servicing the entire request without a thread context switch should
no explicit threads be required for servicing the request (e.g. web page content
obtained from cache).  This also resolves the thread context switching of the
motivating example.


\section{Example implementation of an Asynchronous Operation}

As all participates (except the Asynchronous Operation) in the Proactor pattern
have specific algorithms, the following is an example of an Asynchronous
Operation implementation.  The \texttt{Retrieve data from cache} operation from
the motivating example will be used (Table
\ref{tab:example_request_operations}).

Fig \ref{fig:Example_Method_Operation} shows the example developer
implementation code.  A generic Asynchronous Operation adapter implementation is
used to reflectively invoke the \texttt{retrieveData(\ldots)} method. It will:
\begin{enumerate}
  \item Obtain an instance of the \texttt{CacheOperation} via the \texttt{getDependency(\ldots)} method.
  \item Obtain both the \texttt{key} and \texttt{cache} via the \texttt{getDependency(\ldots)} method \footnote{\texttt{key} is an argument from the previous operation}.
  \item Instantiate a proxy implentation of the \texttt{CacheContinuation} interface that implements the \texttt{cacheMiss(\ldots)} method by invoking the \texttt{doContinuation(\ldots)} method.  This also demonstrates injecting the continuation much like injecting a dependency and is where Continuation Injection derived its name. 
  \item Reflectively invokes the \texttt{retrieveData(\ldots)} with the above arguments.
\end{enumerate}

\begin{figure}[!h]
\begin{verbatim}

    interface CacheContinuations {

        void cacheMiss(String key);
    }

    class CacheOperation {
    
        public Data retrieveData(String key, Cache cache, 
                        CacheContinuations continuations)
                        throws IOException {
        	Data data = cache.get(key);
        	if (data == null) {
        	    continuations.cacheMiss(key);
        	    return null; // finish operation
        	}
        	return data;
        }
    }
\end{verbatim}
\caption[Caption for Code]{Example method used as an implementation of an Asynchronous Operation}
\label{fig:Example_Method_Operation}
\end{figure}

Continuations from the \texttt{retrieveData(\ldots)} method are:
\begin{itemize}
  \item \texttt{cacheMiss(\ldots)} which will be mapped to the \texttt{Retrieve Data from Database} Asynchronous Operation.
  \item Implicit continuation (continuation invoked if no other continuation is invoked) which is mapped to the \texttt{Render HTTP response} \footnote{The return value from the method is used as the argument}.
  \item \texttt{IOException} to be mapped to an Asynchronous Operation providing an error message page.  It may also be mapped to the \texttt{Retrieve Data from Database} Asynchronous Operation to attempt to continue servicing the request.
  \item A default continuation is used should the Asynchronous Operation be cancelled.
\end{itemize}

Because the \texttt{cache} is in local memory it will not have a specific thread
pool configured.  The \texttt{retrieveData(\ldots)} method will therefore be
executed by an implicit thread.

Should however the \texttt{cache} be remotely located requiring network access,
a thread pool can then be assigned to it.  The \texttt{retrieveData(\ldots)}
method will therefore be executed by a thread from this thread pool.  This
demonstrates injecting the thread much like injecting a dependency.

This example demonostrates resolution of the motivating example issues.  The
operation is a single distinct method and may via choice of continuation specify
the next operation (e.g. skipping the \texttt{Retrieve Data from Database}
operation and going straight to the \texttt{Render HTTP response} operation).
The excuting thread may be borrowed (i.e. use the implicit thread) or be
explicitly specified.


\section{Inversion of Control pattern}

Using all three injection patterns together (dependency, thread, continuation)
as implementing patterns to the Proactor pattern forms the Inversion of Control
pattern \footnote{Inversion of Control is not just dependency injection as
suggested by the Inversion of Control layer \cite{ioc}}.

For a method to be executed it requires:
\begin{itemize}
  \item A thread to execute it which Thread Injection inverts control
  \item Arguments for its parameters which Dependency Injection inverts control
  \item Next operations to invoke which Continuation Injection inverts control
\end{itemize}

And therefore all aspects may be inverted in control providing an Inversion of
Control pattern.


\section{Drawbacks}

The Thread Injection and Continuation Injection patterns have provided limited
improvement on the Proactor pattern being hard to debug.  While the patterns
have not directly addressed the Proactor issue of being hard to debug, they do
follow the trend of popular modern web servers by encapsulating developer code
within Asynchronous Operations.  However, the introduction of dependencies
maintaining state between Asynchronous Operations executed by different threads
leaves the possibility for dependencies to be non-thread safe causing difficult
to identify thread synchronization bugs.


\section{Known Uses}

OfficeFloor \cite{officefloor} is the only known use of the Thread Injection and
Continuation Injection pattern.


\section*{Acknowledgment} I thank my wife Melanie for her patience and support
in me developing OfficeFloor.  I also thank my friend Matthew Brown for being a
sounding board to many of my ideas.


\bibliographystyle{style/IEEEtran}
\bibliography{tici}

\end{document}
