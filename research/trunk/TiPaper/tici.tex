%% OfficeFloor - http://www.officefloor.net
%% Copyright (C) 2013 Daniel Sagenschneider
%%
%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%
%% While this document is not a program, it conveys the underlying design 
%% of OfficeFloor (it is the expression of how to implement the ideas of 
%% Thread Injection, Implicit Thread, Continuation Injection, Operation 
%% Orchestration) and as such any program derived from the contents 
%% (expression) of this document is considered conveying (copying/modifying) 
%% the OfficeFloor expression and is therefore subject to the licensing 
%% of OfficeFloor.


%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[prodmode]{style/acmlarge}

% Metadata Information
\acmVolume{V}
\acmNumber{N}
\acmArticle{A}
\articleSeq{S}
\acmYear{YYYY}
\acmMonth{0}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{style/algorithm2e}
\SetAlFnt{\algofont}
\SetAlCapFnt{\algofont}
\SetAlCapNameFnt{\algofont}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}
\renewcommand{\algorithmcfname}{ALGORITHM}

% Page heads
\markboth{D. Sagenschneider}{Thread Injection and Continuation Injection}


\title{Thread Injection and Continuation Injection}
\author{DANIEL SAGENSCHNEIDER \affil{daniel@officefloor.net}}

\begin{abstract}
The Thread Injection and Continuation Injection patterns provide implementing
algorithms for the participants of the Proactor pattern to enable inverting
control for the thread executing and the ordering of operations.  These patterns
combined with Dependency Injection provide an Inversion of Control pattern.
\end{abstract}

\category{X.Y.Z}{To}{be}[determined]

\terms{Design, Performance, Standardization}
\keywords{Continuation Injection, Implicit Thread, Operation Orchestration, Thread Injection}

\acmformat{Sagenschneider, D. 2012.Thread Injection and Continuation Injection.}

\copyr{Copyright 2012 is held by the author}

\begin{document}

\begin{bottomstuff}
This work is the result of the author's development of OfficeFloor.\\
Author's address: D. Sagenschneider, at home; email: daniel@officefloor.net\\

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear this
notice and the full citation on the first page. To copy otherwise, to republish,
to post on servers or to redistribute to lists, requires prior specific
permission. A preliminary version of this paper was presented in a writers'
workshop at the 18th Conference on Pattern Languages of Programs (PLoP).
\end{bottomstuff}

\maketitle

\section{Introduction}

The Proactor pattern \cite{proactor} is used as the basis of popular modern web
servers\footnote{Apache, Microsoft IIS, Nginx and JEE identified from the
Netcraft November 2012 survey.  Google Web Server is also identified as
popular.} to dispatch requests asynchronously to request handlers (Asynchronous
Operations).

The disadvantage of the Proactor pattern is that the ``Asynchronous Operation
Processor must be designed carefully to support prioritization and cancellation
of Asynchronous Operations'' \cite{proactor}.  When not relying on the Operating
System's asynchronous I/O, the Proactor pattern does suggest using a single
thread pool to execute the Asynchronous Operations.  Performance analysis of web
servers identifies the importance of tuning this prioritization
\cite{tuning-important,low-server-footprint,tuning-os-important}.  Furthermore,
the Proactor pattern does not provide algorithms for implementing its
participants.  The Thread Injection pattern presented focuses on addressing the
prioritization algorithms of the Asynchronous Operations by using multiple
thread pools.

The Asynchronous Operation API has also become a single standard interface to
enable servicing dynamic web page content.  The discussion of the Proactor
pattern focused on web servers providing static content with developers
implementing the Proactor Initiator.  Popular web servers however provide
dynamic web page content via developers implementing Asynchronous Operations to
service a request.  To enable portable implementations the Asynchronous
Operation interface has been standardised\footnote{CGI/FastCGI with for
example PHP scripts, Microsoft's HTTP.sys/WAS and JEE Servlets}.

The design of the Proactor pattern was to enable using many Asynchronous
Operations in servicing a HTTP request.  For the popular web servers
standardising of the Asynchronous Operation interface however has focused on the
Proactor benefit of simplification of application synchronization by allowing
only one Asynchronous Operation to synchronously service the entire dynamic web
page content\footnote{JEE Servlet 3.x AsyncContext is enabling developer
implementing code for the Proactor Initiator however this requires the developer
to be aware of thread synchronization complexities}.  The Continuation Injection
pattern presented focuses on addressing this by allowing multiple Asynchronous
Operations to be used for servicing requests for dynamic web page content. It
also provides the means for cancellation of Asynchronous Operations.


\section{A Motivating Example}

A motivating example for the Thread Injection and Continuation Injection
patterns is servicing dynamic web content.  A typical dynamic web request
servicing may use both cached/static content and data retrieved from a database.

Due to the standardising of the Asynchronous Operation interface, requests
involving no I/O or heavy I/O are serviced by the same pool of threads.
If for example the database I/O becomes slow causing all threads to block,
requests requiring only cached content are not prioritized as they are starved
of a thread.

Also for requests requiring only in memory cached content, popular modern web
servers continue to use a separate thread and incurs the cost of one or more
thread context switches.  If the web server knew further details about the
nature of each Asynchronous Operation, it should allow the Asynchronous
Operation to safely borrow the thread to reduce thread context switching.

Table \ref{tab:example_request_operations} lists the operations for servicing an
example HTTP request.  The operations executed differ based on whether there is
a cache hit or miss.  Ideally, as explained above, all operations up to and
including the \texttt{Retrieve data from cache} should be borrowing the thread
to avoid a thread context switch.  A separate thread should then only be used if
the \texttt{Retrieve data from database} operation needs to be executed.  The
remaining operations should then again be borrowing the thread to avoid thread
context switching.

\begin{table}[t]
\tbl{Example operations for servicing a HTTP request from database and cache. The dependencies of each operation are also listed.}{%
\begin{tabular}{|l|l|l|}
\hline
\bfseries Cache Miss Operations & \bfseries Cache Hit Operations & \bfseries Dependencies \\
\hline
Read data from socket & Read data from socket & Selector, Socket \\
\hline
Parse HTTP request & Parse HTTP request & Data read \\
\hline
Dispatch HTTP request & Dispatch HTTP request & HTTP request \\
\hline
Validate client data & Validate client data & HTTP request \\
\hline
Retrieve data from cache & Retrieve data from cache & Client data, \\
(cache miss) & (cache hit) & Cache \\
\hline
Retrieve data from database & - & Client data, \\
 & & Database connection \\
\hline
Render HTTP response & Render HTTP response & Database data \\
\hline
Write HTTP response & Write HTTP response & HTTP response, \\ 
 & & Socket \\
\hline
\end{tabular}}
\label{tab:example_request_operations}
\end{table}

The ability to string discrete operations together and choose the executing
thread for each operation, with both undertaken externally to the operations, is
the focus of the Thread Injection and Continuation Injection patterns.


\section{Dependency Injection}

The naming of the Thread Injection and Continuation Injection pattern is because
of their close association to the Dependency Injection pattern.

The Dependency Injection pattern enables constructing objects using extrinsic
dependency information to load dependencies without the need of the client
object requiring awareness of the dependencies \cite{ioc}.  This allows
implementations to be swapped without syntactic changes.

The Dependency Injection pattern therefore enables:
\begin{enumerate}
  \item A single interface for multiple implementations
  \item Meta-data about dependencies required for the implementation
  \item Means to provide one or more differing objects to the implementation
\end{enumerate}

These properties of the Dependency Injection pattern are important for the
patterns described:
\begin{itemize}
  \item Single interface is necessary for the Asynchronous Operations.
  \item Meta-data about dependencies provides Thread Injection the necessary information for dispatching Asynchronous Operations to the appropriate thread pool.
  \item Continuations encapsulating the Proactor Completion Handlers/Dispatchers can be dependency injected into Asynchronous Operations.
\end{itemize}


\section{Thread Injection}

The Thread Injection pattern addresses both the implementation of the
Asynchronous Operation Processor and providing a standard interface to obtain
prioritization information from the Asynchronous Operation.

As already mentioned, the Proactor pattern specifies that the Asynchronous
Operation API must be both portable and flexible.  While this applies to the API
between the Proactor Initiator and Asynchronous Operation, it also must apply to
the API between the Asynchronous Operation and Asynchronous Operation Processor
to decouple them.  This will enable portable developer implementations of
Asynchronous Operations (such as generating dynamic web page content). 

For the Thread Injection pattern, all Asynchronous Operations are constructed
via extrinsic dependency management \cite{ioc} to allow a standard interface.
The construction of the Asynchronous Operation is encapsulated in the dependency
injection factory.  This enables both the interfaces to the Proactor Initiator
and Asynchronous Operation Processor to be standardised as dependencies are
injected.

Standardising the interface between the Proactor Initiator and Asynchronous
Operation is not necessary for Thread Injection.  It is however necessary for
Continuation Injection discussed later.

The interface for the Asynchronous Operation is provided in Fig
\ref{fig:AO_interface_AOP}.  The \texttt{execute(\ldots)} method is invoked by
the thread from the chosen thread pool to execute the implementation of the
Asynchronous Operation.  The \texttt{cancel(\ldots)} method provides means for
Asynchronous Operations to undertake application specific behaviour on being
cancelled.  The \texttt{AsynchronousOperationContext} parameter and
\texttt{getContinuationIds()} method provides means for Continuation Injection
explained later.

\begin{figure}[tp]
\centering
\begin{verbatim}
    interface DependencyInjectionFactory {
    
        Type[] getRequiredDependencyTypes(String operationId);
        
        AsynchronousOperation createOperation(String operationId);
    }

    interface AsynchronousOperation {
    
        void execute(AsynchronousOperationContext context);
        
        void cancel(Exception cause);
        
        String[] getContinuationIds();
    }
\end{verbatim}
\caption{Asynchronous Operation interface and required Dependency Injection pattern interface\footnotemark}
\label{fig:AO_interface_AOP}
\end{figure}
\footnotetext{A rudimentary example implementation of the \texttt{DependencyInjectionFactory} is wrapping Spring's \cite{spring} \texttt{DefaultListableBeanFactory} to implement \texttt{createOperation(\ldots)} by calling \texttt{getBean(\ldots)} and \texttt{getRequiredDependencyTypes(\ldots)} by recursively calling \texttt{getBeanDefinition(\ldots)}/\texttt{getDependsOn()} to create the list of types.  A more functional example implementation would utilise Spring's \texttt{ApplicationContext} to manage the context for the Asynchronous Operations and their dependencies.}


\subsection{Prioritizing Asynchronous Operations}

The prioritization provided by the Thread Injection pattern is achieved by using
the\texttt{getRequiredDependencyTypes(\ldots)} method to obtain the extrinsic
dependency information for an Asynchronous Operation\footnote{Dependency
Injection frameworks using qualification to identify dependencies of the same
type may return a type object containing both class and qualifier rather than
just a class.  The thread pool matching may then incorporate the qualifier}.

The developer configures one or more thread pools responsible for Asynchronous
Operations with a particular type of dependency\footnote{Thread pools may be
associated to more than one dependency type}.  The Asynchronous Operation is
then matched by its required dependency types to a Thread Pool responsible for
one or more of the dependency types. 

Table \ref{tab:example_request_thread_pools} provides an example set of thread
pools for the motivating example.  A thread pool is configured for Asynchronous
Operations with a \texttt{Database connection}.  As the \texttt{Database
connection} is only available via Dependency Injection, all Asynchronous
Operations requiring I/O with the database must depend on the \texttt{Database
connection} and are subsequently mapped to be executed by a thread from the
\texttt{Database} thread pool.  The remaining operations have their own thread
pools allowing them to continue to be executed even if the database I/O is
causing thread starvation within its own thread pool.

\begin{table}[t]
\tbl{Example assigning of thread pool to Asynchronous Operations by dependency type}{%
\begin{tabular}{|l||l||l|}
\hline
\bfseries Thread Pool & \bfseries Dependency Type & \bfseries Asynchronous Operation \\
\hline
Network & Selector & Read data from socket \\
\hline
Database & Database connection & Retrieve data from database \\
\hline
Default & - & Parse HTTP request, \\
& & Dispatch HTTP request, \\
& & Validate client data, \\ 
& & Retrieve data from cache, \\
& & Render HTTP response, \\
& & Write HTTP response \\
\hline
\end{tabular}}
\label{tab:example_request_thread_pools}
\end{table}

The Thread Injection pattern can therefore be considered a style of cohort
scheduling \cite{cohort} to group operations with similar dependencies (and
inferring from that similar functionality).  It however works at the application
scheduling level and allows use of any Operating System thread scheduling
algorithms.  Furthermore, tuning the thread pools (such as restricting number of
threads or changing the pool's thread nice values) allows prioritizing threads
and subsequently prioritizing groups of related Asynchronous Operations.

As the dependencies for each Asynchronous Operation is static, at application
start up time the Asynchronous Operation Processor may preprocess and cache the
mapping of Asynchronous Operations to thread pools to reduce runtime decision
overheads.  This pre-mapping of Asynchronous Operations may also provide
warnings where dependencies of an Asynchronous Operation may make it possible to
be mapped to multiple thread pools.  Different conflict mapping resolutions may
be employed, however ordering the thread pools and assigning based on first
match is a sufficiently adequate algorithm.

The result for the motivating example is that the operations for servicing the
cached request can now be prioritized.  This can occur even if the database
driver has become non-responsive blocking all threads attempting to use a
database connection.  Furthermore, as the application becomes more complex with
an increasing number of downstream systems, each downstream system's performance
impacts may be isolated by assigning it its own thread pool.  This has requests
requiring a slow downstream system to be deprioritized, allowing other requests
to be serviced.

From the perspective of the Asynchronous Operation, the developer is now able to
configure which thread pool will execute each Asynchronous Operation.  This
effectively injects the thread for execution similar to injecting a dependency
for use.  Hence the name of the pattern, Thread Injection.


\subsection{Cancelling Asynchronous Operations}

The \texttt{cancel(Exception)} provides the means for the Asynchronous Operation
Processor to cancel the Asynchronous Operation.  Once invoked, the Asynchronous
Operation Processor may discard the Asynchronous Operation.

The implementation of the \texttt{cancel(Exception)} method is the responsibility
of the Asynchronous Operation as it will likely be specific to the it's
implementation.  The Continuation Injection pattern explained later provides a
means to alleviate this from the Asynchronous Operation's implementation.

As each thread pool is executing Asynchronous Operations for a particular
dependency (or set of dependencies), this allows for adaptive resource management
and admission control regarding the dependency \cite{seda}.  This enables both
the number of threads and dependencies to be dynamically altered to improve
throughput.  However when maximum throughput is reached, additional Asynchronous
Operations above this threshold can be cancelled.


\section{Continuation Injection}

Continuation Injection focuses on the algorithms implementing the Proactor pattern's
Proactive Initiator, Completion Handler and Completion Dispatcher participants
to enable multiple Asynchronous Operations to be utilised in servicing HTTP
requests.

The Continuation Injection pattern relies on providing the
\texttt{AsynchronousOperationContext} (Fig \ref{fig:AOC_interface}) to the
Asynchronous Operation (Fig \ref{fig:AO_interface_AOP}).  The
\texttt{getDependency(\ldots)} method provides retrieval of the extrinsically
defined dependencies for the Asynchronous Operation (Dependency Injection).  The
remaining methods are for Continuation Injection.

\begin{figure}[tp]
\centering
\begin{verbatim}
    interface AsynchronousOperationContext {
    
        Object getDependency(String dependencyId);
        
        Future doContinuation(String continuationId, 
                                Object parameter);
        
        void continueOperation();
    }
\end{verbatim}
\caption{Asynchronous Operation Context interface\footnotemark}
\label{fig:AOC_interface}
\end{figure}
\footnotetext{Integer identifiers may be used for fast array look ups rather than strings}

The \texttt{doContinuation(\ldots)} method triggers the Proactive Initiator to
undertake an Asynchronous Operation.  The Proactive Initiator is aware of the
possible continuations of the Asynchronous Operation via the
\texttt{getContinuationIds()} method (Fig \ref{fig:AO_interface_AOP}).  As the
continuation identifiers are static for each Asynchronous Operation, developer
configuration provides the Asynchronous Operation continuation mapping to the
respective handling Asynchronous Operation.  To ease debugging and better
developer understanding of the application, the configuration may be graphical
where Asynchronous Operations are nodes and continuation mappings are directed
lines.  Due to the similarity of configuration with service orchestration, this
can be identified as Operation Orchestration\footnote{Operation orchestration
may also be identified as function, procedure or method orchestration
dependening on the implementing language}.

As the continuation asynchronously invokes the operation, it may use the
returned \texttt{Future} to determine when the sequence of triggered
Asynchronous Operations has completed\footnote{State is managed within the
dependencies so there is no need for a return value from the \texttt{Future}}.
This enables process continuations \cite{process-continuation} to be spawned by
repeatedly calling \texttt{doContinuation(\ldots)} to aid in resolving such issues
as the reverse 10K problem \cite{reverse-ten-k-problem}.

Furthermore as continuations result in Asynchronous Operations, they need not
only be invoked by Asynchronous Operations. Fig \ref{fig:DC_interface}
illustrates a possible interface that can be injected into dependencies to
invoke an Asynchronous Operation.  This enables dependencies to effectively
become Active Objects \cite{active-object} when necessary\footnote{The web
server HTTP(S) sockets would for example typically be implemented using
Dependency Continuations}.

\begin{figure}[tp]
\begin{verbatim}
    interface DependencyContinuation {
            
        void doContinuation(Object parameter);
    }
\end{verbatim}
\caption{Injected interface for a dependency to invoke a continuation}
\label{fig:DC_interface}
\end{figure}

The \texttt{continueOperation()} method enables executing the current
Asynchronous Operation again.  The Asynchronous Operation Processor may be
implemented to defer execution of an Asynchronous Operation until invoked
continuations by the Asynchronous Operation or any of its dependencies are
completed.  This for example allows deferring executing the Asynchronous
Operation again until an Operating System asynchronous I/O operation completes -
a key aspect of the Proactor pattern.

Continuation Injection therefore enables stringing together multiple
Asynchronous Operations to service the HTTP request.  This can be considered a
form of continuation-passing style \cite{continuations} except that the
continuation is dependency injected rather than passed as a parameter.  The
added benefit of dependency injecting the continuation is that the Asynchronous
Operation is free to depend on as many continuations as necessary.  It also
means that as the application evolves, the Asynchronous Operation's
implementation may require differing continuations which is a configuration
change rather than a code change as would typically be the case without the
indirection provided by the Continuation Injection pattern.


\subsection{Initial Asynchronous Operation to service a HTTP request}

For web servers, URL continuations \cite{url-continuation} are used to invoke
the first Asynchronous Operation in the string\footnote{A similar approach may
be taken by other User Interface types (such as a rich GUI) with the user event
being mapped to the first Asychnronous Operation}.  A URL may be associated to
an Asynchronous Operation by developer configuration.  This Asynchronous
Operation then becomes the first operation to be invoked for servicing a HTTP
request for that URL.  This configuration may be included in the Continuation
Injection configuration as an attribute of the Asynchronous Operation node.

Providing identifiers to Asynchronous Operations is also a convenient means to
ease maintenance of web pages.  Rather than embedding the URL in the web page
content, the Asynchronous Operation identifier is used.  When the page is
rendered for the client, the identifiers are replaced with the actual URLs.
This allows the URLs to be changed without needing to change web pages.

Substituting the Asynchronous Operation URLs at page rendering time also enables
distributed load balancing.  For a server to balance load to a different server
it substitutes URLs for Asynchronous Operations on the other server. The
appropriate clients will then continue with another server and subsequently
allow balancing load across the distributed servers.


\subsection{Continuation for cancelling an Asynchronous Operation}

Cancelling the Asynchronous Operation is handled by the Asynchronous Operation
invoking a continuation.  On the Asynchronous Operation Processor invoking the
\texttt{cancel(Exception)} method, the Asynchronous Operation will clean up any
resources and then invoke a continuation for an Asynchronous Operation executed
in another thread pool\footnote{For a web server this Asynchronous Operation
could for example send a web page indicating the server is temporarily busy or
it may send a redirect to a less busy web server}.

Each Asynchronous Operation may specifically specify the continuation or a
default continuation may be configured across a set of Asynchronous Operations.
The default continuation will be mapped to an Asynchronous Operation that
interrogates the \texttt{cause} and undertakes appropriate further Asynchronous
Operations specific to the required application behaviour.  This is very similar
to a \texttt{catch} block for handling an \texttt{Exception}.


\section{Implicit Thread}

When using the Thread Injection and Continuation Injection patterns together,
implicit threads may be used to reduce thread context switching.

The continuation may borrow the thread of the invoking Asynchronous Operation if
it results in execution by the same thread pool.  The Proactor Pattern
stipulates that Asynchronous Operations ``are performed without borrowing the
application's thread of control'' \cite{proactor} and this is the focus of the
Reactor Pattern \cite{reactor}.  Rather than dispatching back to the same thread
pool the continued Asynchronous Operations may safely borrow the thread to avoid
the overhead of a thread context switch.

This same idea is also extended to the default thread pool for the Thread
Injection pattern.  For an Asynchronous Operation not requiring any dependencies
for dispatching to a specific thread pool, the Asynchronous Operation is deemed
cheaper to be executed by borrowing the thread than incurring the cost of a
thread context switch.

The borrowed thread is the implicit thread.  Like an implicit continuation that
executes the next operation \cite{continuations}, the implicit thread executes
the next operation unless an explicit thread is required.  This can result in
the web server servicing the entire request without a thread context switch
should all the Asynchronous Operations involved not require an explicit thread
(e.g. web page content obtained from cache).

Using implicit threads resolves the thread context switching of the motivating
example.  Only the \texttt{Retrieve data from database} operation has an
explicit thread that would cause a thread context switch.  All remaining
operations to service the request would use implicit threads (i.e. borrow the
thread).


\section{Distributing Asynchronous Operations}

As continuations asynchronously invoke Asynchronous Operations, the Asynchronous
Operation need not reside on the same server.  The dependency injected
continuation can be configured to invoke an Asynchronous Operation on another
server.  The continuation may synchronously send the continuation arguments
(e.g. HTTP request) or the arguments may be asynchronously communicated (e.g.
queue).  The asynchronous communication decouples the arguments (message) from
the sending Asynchronous Operation enabling the Asynchronous Operations to
adhere to the principles of an Actor \cite{actors}\footnote{Invoking any number
of dependency injected continuations enables the remaining Actor principles}.

Distributing Asynchronous Operations heterogeneously can also be undertaking by
configuring the responsible thread pool to reside on another server.  On
invoking the continuation, the continuation arguments are communicated to the
server\footnote{May be cluster of servers} containing the thread pool to execute
the Asynchronous Operation.  The dependency injection context state to be
reinstated on the other server may also be communicated with the continuation
arguments depending on thread pool mapping configuration.  Mapping the
responsible thread pool to another server is useful for example to co-locate
certain Asynchronous Operations geographically or have certain Asynchronous
Operations run on particular hardware.

The Internet is an example implementation that utilises both Asynchronous
Operation heterogeneous clustering and continuations to other servers.  The URL
continuation, for example by a user clicking on a link, is sent to the server
containing the thread pool (modern web server following Proactor pattern).  The
web server continues the processing by sending the HTTP response to the client
web browser (another server\footnote{The user (client) of the web browser
(server) can also be considered a thread pool for continuing operations with the
web browser}).

The evolution to Cloud Computing can also be described as a form of Asynchronous
Operation heterogeneous clustering.  The number of servers containing a
particular thread pool are dynamically managed based on the number of
Asynchronous Operations to execute.  This dynamic management enables better use
of available servers, as only the necessary number of servers are used for each
thread pool to execute their respective current load of Asynchronous Operations.


\section{Example implementation of an Asynchronous Operation}

As the Thread Injection and Continuation Injection pattern define the algorithms
for all participates (except the Asynchronous Operation) in the Proactor
pattern, the following is an example of an Asynchronous Operation
implementation.  The \texttt{Retrieve data from cache} operation from the
motivating example will be used (Table \ref{tab:example_request_operations}).

Fig \ref{fig:Example_Method_Operation} shows the example developer
implementation code.  A generic Asynchronous Operation adapter implementation is
used to reflectively invoke the \texttt{retrieveData(\ldots)} method. It will:
\begin{enumerate}
  \item Obtain an instance of the \texttt{CacheOperation} via its context's \texttt{getDependency(\ldots)} method.
  \item Obtain both the \texttt{key} and \texttt{cache} again via the \texttt{getDependency(\ldots)} method\footnote{\texttt{key} is an argument from the previous operation}.
  \item Instantiate a proxy implementation of the \texttt{CacheContinuation} interface that implements the \texttt{cacheMiss(\ldots)} method by invoking the \texttt{doContinuation(\ldots)} method.  This also demonstrates injecting the continuation much like injecting a dependency and is where Continuation Injection derived its name. 
  \item Reflectively invokes the \texttt{retrieveData(\ldots)} with the above arguments.
\end{enumerate}

\begin{figure}[tp]
\centering
\begin{verbatim}

    interface CacheContinuations {

        void cacheMiss(String key);
    }

    class CacheOperation {
    
        public Data retrieveData(String key, Cache cache, 
                        CacheContinuations continuations)
                        throws IOException {
        	Data data = cache.get(key);
        	if (data == null) {
        	    continuations.cacheMiss(key);
        	    return null; // finish operation
        	}
        	return data;
        }
    }
\end{verbatim}
\caption{Example method used as an implementation of an Asynchronous Operation}
\label{fig:Example_Method_Operation}
\end{figure}

Continuations from the \texttt{retrieveData(\ldots)} method are:
\begin{itemize}
  \item \texttt{cacheMiss(\ldots)} which will be mapped to the \texttt{Retrieve data from database} Asynchronous Operation.
  \item Implicit continuation (continuation invoked if no other continuation is invoked) which is mapped to the \texttt{Render HTTP response} \footnote{The return value from the method is used as the argument}.
  \item \texttt{IOException} to be mapped to an Asynchronous Operation providing an error message page.  It may also be mapped to the \texttt{Retrieve data from database} Asynchronous Operation to attempt to continue servicing the request.
  \item A default continuation is used should the Asynchronous Operation be cancelled.
\end{itemize}

Because the \texttt{cache} is in local memory it will not have a specific thread
pool configured.  The \texttt{retrieveData(\ldots)} method will therefore be
executed by an implicit thread.

Should however the \texttt{cache} be remotely located requiring network access,
a thread pool can then be assigned to it.  The \texttt{retrieveData(\ldots)}
method will therefore be executed by a thread from this thread pool.  This
demonstrates injecting the thread much like injecting a dependency.

This example demonstrates resolution of the motivating example issues.  The
operation is a single distinct method and may via choice of continuation specify
the next operation (e.g. skipping the \texttt{Retrieve data from database}
operation and going straight to the \texttt{Render HTTP response} operation).
The executing thread may be borrowed (i.e. use the implicit thread) or be
explicitly specified.  Additional marker dependencies may be used to aid in
tuning the assigning of Asynchronous Operations to particular thread pools.


\section{Inversion of Control}

Using all three injection patterns together (dependency, thread, continuation)
as implementing patterns to the Proactor pattern potentially forms the Inversion
of Control pattern\footnote{Inversion of Control is not just dependency
injection as suggested by the Inversion of Control layer \cite{ioc}.  It is
better described as the formula: Inversion of Control = Dependency Injection +
Thread Injection + Continuation Injection (or its shorter form: IoC = DI + TI +
CI)}.

For a method to be executed it requires:
\begin{itemize}
  \item A thread to execute it which Thread Injection inverts control
  \item Arguments for its parameters which Dependency Injection inverts control
  \item Next operations to invoke which Continuation Injection inverts control
\end{itemize}

And therefore all aspects may be inverted in control providing an Inversion of
Control pattern.

As control may be inverted for all aspects of the method, it has potentially
made the Asynchronous Operation the software equivalent of an architectural
\textit{brick}\footnote{The author finds software building block an over used
term and that \textit{Software Brick} a more tangible analogy}.  The
Asynchronous Operations have standard interfaces allowing them to be used
together to create the equivalent of \textit{walls}, \textit{buildings} and
further complex structures.


\section{Drawbacks}

The Thread Injection and Continuation Injection patterns have provided limited
improvement on the Proactor pattern being hard to debug.  While the patterns
have not directly addressed the Proactor issue of being hard to debug, they do
follow the trend of popular modern web servers by encapsulating developer code
within Asynchronous Operations.  However, the introduction of dependencies
maintaining state between Asynchronous Operations executed by different threads
leaves the possibility for dependencies to be non-thread safe causing difficult
to identify thread synchronization bugs.


\section{Known Uses}

OfficeFloor \cite{officefloor} is the only known framework implementing the
Thread Injection and Continuation Injection pattern.  OfficeFloor identifies
Asynchronous Operations as Jobs\footnote{Task is the adapted interface within a
Job for application developers to implement} which originates from its original
design to model application architecture after the way work is processed within
an office\footnote{This is where the name is derived. The OfficeFloor houses
the system of coordinating the execution of Jobs}.  The author identified the
Thread Injection and Continuation Injection patterns through developing
OfficeFloor.


\section*{Acknowledgment} I thank my wife Melanie for her patience and support
in me developing OfficeFloor on top of my day job.  If she was any other person,
OfficeFloor would not have been built and this work would not have resulted from
it.  I also thank my friend Matthew Brown for being a sounding board to many of
my ideas.


\bibliographystyle{style/acmlarge}
\bibliography{tici}

\end{document}
