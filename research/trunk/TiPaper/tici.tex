%% OfficeFloor - http://www.officefloor.net
%% Copyright (C) 2013 Daniel Sagenschneider
%%
%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%
%% While this document is not a program, it conveys the underlying design 
%% of OfficeFloor (it is the expression of how to implement the ideas of 
%% Thread Injection, Implicit Thread, Continuation Injection, Operation 
%% Orchestration) and as such any program derived from the contents 
%% (expression) of this document is considered conveying (copying/modifying) 
%% the OfficeFloor expression and is therefore subject to the licensing 
%% of OfficeFloor.


%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[prodmode]{style/acmlarge}

% Metadata Information
\acmVolume{V}
\acmNumber{N}
\acmArticle{A}
\articleSeq{S}
\acmYear{YYYY}
\acmMonth{0}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{style/algorithm2e}
\SetAlFnt{\algofont}
\SetAlCapFnt{\algofont}
\SetAlCapNameFnt{\algofont}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}
\renewcommand{\algorithmcfname}{ALGORITHM}

% Page heads
\markboth{D. Sagenschneider}{Thread Injection and Continuation Injection}


\title{Thread Injection and Continuation Injection}
\author{DANIEL SAGENSCHNEIDER \affil{daniel@officefloor.net}}

\begin{abstract}
The Thread Injection and Continuation Injection patterns provide implementing
algorithms for the participants of the Proactor pattern to enable inverting
control for the thread executing and the ordering of operations.  These patterns
combined with Dependency Injection provide an Inversion of Control pattern.
\end{abstract}

\category{X.Y.Z}{To}{be}[determined]

\terms{Design, Performance, Standardization}
\keywords{Continuation Injection, Implicit Thread, Operation Orchestration, Thread Injection}

\acmformat{Sagenschneider, D. 2013.Thread Injection and Continuation Injection.}

\copyr{Copyright 2013 is held by the author}

\begin{document}

\begin{bottomstuff}
This work is the result of the author's development of OfficeFloor.\\
Author's address: D. Sagenschneider, at home; email: daniel@officefloor.net\\

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear this
notice and the full citation on the first page. To copy otherwise, to republish,
to post on servers or to redistribute to lists, requires prior specific
permission. A preliminary version of this paper was presented in a writers'
workshop at the 18th Conference on Pattern Languages of Programs (PLoP).
\end{bottomstuff}

\maketitle


\section{Introduction}

The Proactor pattern \cite{proactor} is used as the basis of popular modern web
servers\footnote{Apache, Microsoft IIS, Nginx and JEE identified from the
Netcraft November 2012 survey.  Google Web Server is also identified as
popular.} to dispatch requests asynchronously to request handlers (Asynchronous
Operations).  The Proactor pattern however does not specify implementating
algorithms for its participants leaving developers to deal with prioritization
and cancellation of Asynchronous Operations.

As web servers evolved to handle more dynamic content following the Proactor
pattern, the Asynchronous Operation interface became standardised to encapsulate
the developer implementations of servicing dynamic content\footnote{CGI/FastCGI
with for example PHP scripts, Microsoft's HTTP.sys/WAS and JEE Servlets.}.  This
standardisation has resulted in allowing only one Asynchronous Operation to
synchronously service the entire dynamic content of the request\footnote{JEE
Servlet 3.x AsyncContext is enabling developer implementing code for the
Proactor Initiator.  However, this requires the developer to be aware of thread
synchronization complexities.} and is more commonly known as the
thread-per-request pattern \cite{thread-per-request}.

The Thread Injection and Continuation Injection patterns presented in this paper
remove the constraints imposed by the thread-per-request pattern and provide
implementating algorithms for prioritization and cancellation of Asynchronous
Operations.  Furthermore, using the Thread Injection and Continuation Injection
patterns with the Dependency Injection pattern \cite{ioc} as implementing
algorithms to the Proactor pattern provides the flexibility necessary for an
Inversion of Control pattern.


\section{Overview}

This paper first presents a motivating example for both the Thread Injection
pattern and Continuation Injection pattern.  The Thread Injection and
Continuation Injection patterns are then presented.  After presenting the
patterns individually, discussion will be provided on combining the Thread
Injection and Continuation Injection patterns together with the Proactor and
Dependency Injection patterns to implement a Web Server and also realise an
Inversion of Control pattern.  The resolution of the motivating example is also
presented.

For ease of reading, figure \ref{fig:InjectionInterfaces} describes the combined
interfaces for the Thread Injection and the Continuation Injection patterns.
Also for completeness of the Inversion of Control pattern presented in this
paper, the well documented Dependency Injection pattern \cite{ioc} interface is
also included via the \texttt{DependencyInjectionFactory}\footnote{A rudimentary
example implementation of the \texttt{DependencyInjectionFactory} is wrapping
Spring's \cite{spring} \texttt{DefaultListableBeanFactory} to implement
\texttt{createOperation(\ldots)} by calling \texttt{getBean(\ldots)} and
implement \texttt{getRequiredDependencyTypes(\ldots)} by recursively calling
\texttt{getBeanDefinition(\ldots)}/\texttt{getDependsOn()} to create the list of
types.  A more functional example implementation would utilize Spring's
\texttt{ApplicationContext} to manage the context for the Asynchronous
Operations and their dependencies.} and the \texttt{getDependency(\ldots)}
method\footnote{The \texttt{getDependency(\ldots)} method provides retrieval of
the extrinsically defined dependencies for the Asynchronous Operation.  An
example implementation of this method would be calling Spring's \cite{spring}
\texttt{getBean(\ldots)} method.}.

\begin{figure}[tp]
\centering
\begin{verbatim}
    interface AsynchronousOperation {
        void execute(AsynchronousOperationContext context);
        void cancel(Exception cause);
        String[] getContinuationIds();
    }

    interface AsynchronousOperationContext {
        Object getDependency(String dependencyId);
        Future doContinuation(String continuationId, Object parameter);
        void continueOperation();
    }
    
    interface DependencyInjectionFactory {
        Type[] getRequiredDependencyTypes(String operationId);
        AsynchronousOperation createOperation(String operationId);
    }
\end{verbatim}
\caption{Combined Thread Injection, Continuation Injection and Dependency Injection pattern interface\footnotemark}
\label{fig:InjectionInterfaces}
\end{figure}
\footnotetext{Integer identifiers may be used for fast array look ups rather than strings.}

As the Thread Injection and Continuation Injection patterns provide implementing
algorithms for the Proactor pattern participants, the Proactor pattern
participants have been summarised in table \ref{tab:ProactorParticipants}.

\begin{table}[t]
\tbl{Proactor pattern participants.}{%
\begin{tabular}{|l|l|}
\hline
\bfseries Participant & \bfseries Responsibilities \\
\hline
Proactor Initiator & Initiates the Asynchronous Operation and \\ 
 & registers both a Completion Dispatcher and \\
 & Completion Handler with the Asynchronous \\
 & Operation Processor.\\
\hline
Completion Dispatcher and & Notified of the completion and handles the \\
Completion Handler & completion of an Asynchronous Operation. \\
\hline
Asynchronous Operation & Operation to be undertaken. \\
\hline
Asynchronous Operation Processor & Execution of the Asynchronous Operations. \\
\hline
\end{tabular}}
\label{tab:ProactorParticipants}
\end{table}



\section{A Motivating Example}

A motivating example for the Thread Injection and Continuation Injection
patterns is servicing dynamic web content.  A typical dynamic web request
servicing may use both cached/static content and data retrieved from a database.

Due to the standardizing of the Asynchronous Operation interface by popular
modern web servers, requests involving no I/O or heavy I/O are serviced by the
same pool of threads.  If for example the database I/O becomes slow causing all
threads to block, requests requiring only cached content are not prioritized as
they are starved of a thread.

Furthermore, for requests requiring only in memory cached content, popular
modern web servers continue to use a separate thread that incurs the cost of one
or more thread context switches.  If the web server knew further details about
the nature of each Asynchronous Operation, it should allow the Asynchronous
Operation to borrow the thread to reduce thread context switching.

Table \ref{tab:example_request_operations} lists the operations for servicing an
example HTTP request.  The operations executed differ based on whether there is
a cache hit or miss.  Ideally, as explained above, all operations up to and
including the \texttt{Retrieve data from cache} should be borrowing the thread
to avoid a thread context switch.  A separate thread should then only be used if
the \texttt{Retrieve data from database} operation needs to be executed so that
the main thread does not block causing potential for thread starvation.  The
remaining operations should then again be borrowing the thread to avoid thread
context switching.

\begin{table}[t]
\tbl{Example operations for servicing a HTTP request from database and cache. The dependencies of each operation are also listed.}{%
\begin{tabular}{|l|l|l|}
\hline
\bfseries Cache Miss Operations & \bfseries Cache Hit Operations & \bfseries Dependencies \\
\hline
Read data from socket & Read data from socket & Selector, Socket \\
\hline
Parse HTTP request & Parse HTTP request & Data read \\
\hline
Dispatch HTTP request & Dispatch HTTP request & HTTP request \\
\hline
Validate client data & Validate client data & HTTP request \\
\hline
Retrieve data from cache & Retrieve data from cache & Client data, \\
(cache miss) & (cache hit) & Cache \\
\hline
Retrieve data from database & - & Client data, \\
 & & Database connection \\
\hline
Render HTTP response & Render HTTP response & Database data \\
\hline
Write HTTP response & Write HTTP response & HTTP response, \\ 
 & & Socket \\
\hline
\end{tabular}}
\label{tab:example_request_operations}
\end{table}



\section{Continuation Injection}


\subsection{Problem}

\textbf{Remove the thread-per-request constraint of a single Asynchronous Operation to enable using multiple Asynchronous Operations to service a request.}


\subsection{Context}

The Asynchronous Operation interface has become a single standard interface to
enable servicing dynamic web content.  The discussion of the Proactor pattern
focused on web servers providing static content with developers implementing the
Proactor Initiator participant.  In contrast, popular web servers provide
dynamic web content via developers implementing the Asynchronous Operation
participant to service a request.  To enable portable implementations of dynamic
web content servicing the Asynchronous Operation interface has been
standardized\footnote{CGI/FastCGI with for example PHP scripts, Microsoft's
HTTP.sys/WAS and JEE Servlets.}.

The design of the Proactor pattern was to enable using many Asynchronous
Operations in servicing a HTTP request.  However, web servers standardizing of
the Asynchronous Operation interface has focused on the Proactor benefit of
simplification of application synchronization \cite[p. 7]{proactor}.  This has
resulted in only allowing one Asynchronous Operation to synchronously service
the entire dynamic web page content and is more commonly known as the
thread-per-request pattern \cite{thread-per-request}.


\subsection{Forces}

The thread-per-request pattern used by modern popular web servers imposes a
single synchronous interface on an Asynchronous Operation that prevents
asynchronous use\footnote{The thread of the current Asynchronous Operation must
be blocked to use another Asynchronous Operation, otherwise there will not be a
thread available as per the thread-per-request pattern to send the response.} of
other Asynchronous Operations (such as asynchronous Operating System I/O
operations).

The synchronous nature of thread-per-request constraint also imposes constraints
in inverting the control over the order of operations.  As the sequence of
operations via thread-per-request is typically undertaken via synchronous direct
method calls, the thread-per-request pattern provides no indirection to invert
the control of the order operations are executed.

Furthermore, as the number of downstream systems increases from a typical single
database to a variety of services (reverse 10K problem
\cite{reverse-ten-k-problem}), the thread-per-request pattern requires the
developer to manually handle the multi-threading issues of concurrent
communication to downstream systems to efficiently service a request.  This
negates the Proactor pattern's benefit of simplification of application
synchronization \cite[p. 7]{proactor} as the developer is required to spawn and
manage threads.


\subsection{Solution}

\textbf{Therefore, provide a context object to the Asynchronous Operation to enable invoking other Asynchronous Operations.}

The Continuation Injection pattern relies on providing the
\texttt{AsynchronousOperationContext} to the \texttt{AsynchronousOperation} (Fig
\ref{fig:InjectionInterfaces}).  The \texttt{AsynchronousOperationContext}
contains a mapping of \texttt{continuationId} to its handling Asynchronous
Operation.  As each mapping is in effect a continuation, this allows injecting
the necessary continuations into the \texttt{AsynchronousOperation}.

The \texttt{doContinuation(\ldots)} method triggers an Asynchronous Operation.
As the \texttt{continuationId}s are static for each Asynchronous Operation,
developer configuration provides the Asynchronous Operation continuation mapping
to the respective handling Asynchronous Operation.  Developer tools may use the
\texttt{getContinuationIds()} method to obtain the list of continuations to aid
the developer in the mapping configuration.

The \texttt{continueOperation()} method enables executing the current
Asynchronous Operation again.  The Asynchronous Operation Processor may be
implemented to defer execution of an Asynchronous Operation until invoked
continuations by the Asynchronous Operation are completed.  This for example
allows deferring the execution of the Asynchronous Operation again until an
Operating System asynchronous I/O operation completes - a key aspect of the
Proactor pattern.


\subsection{Consequences}

The Continuation Injection pattern provides the algorithms implementing the
Proactor pattern's Proactive Initiator, Completion Dispatcher and and Completion
Handler participants.  As the continuations trigger the Proactor Initiator to
invoke Asynchronous Operations, the respective registered Completion
Dispatcher/Handler notify the Proactor Initiator when the Asynchronous Operation
completes.  Using a Proactor Initiator per request to track completion of
Asynchronous Operations allows sending the response once all Asynchronous
Operations for the request are complete.

As the continuation asynchronously invokes the Asynchronous Operation, the
returned \texttt{Future} may be used to determine when the sequence of triggered
Asynchronous Operations has completed\footnote{State is managed within the
dependencies so there is no need for a return value from the \texttt{Future}.}.
The \texttt{Future} would utilise the Proactor Initiator's tracking of
Asynchronous Operation completion to determine when the tree of Asynchronous
Operations realising the continuation has completed.  This enables process
continuations \cite{process-continuation} to be spawned by repeatedly calling
\texttt{doContinuation(\ldots)}.  The process continuations aid in resolving the
reverse 10K problem \cite{reverse-ten-k-problem} by executing multiple
Asynchronous Operations concurrently.

While the Proactor pattern focuses on asynchronous interaction between
Asynchronous Operations, the \texttt{AsynchronousOperationContext} does not
restrict the servicing of the continuation invocation from being synchronous.
In cases where it is more efficient to synchronously invoke the Asynchronous
Operation and avoid the thread-context switching overheads, this can be
controlled by the developer with a flag in the continuation mapping
configuration.  In contrast, having synchronous interaction be imposed by the
interface (as per thread-per-request) causes overheads for developers to
manually manage in code the use of asynchronous interaction.

The mapping of \texttt{continuationId} to \texttt{operationId} (Asynchronous
Operation) is contained within configuration.  This enables changing the
handling Asynchronous Operation without changing code\footnote{The continuation
parameter may be type validated against the handling Asynchronous Operation to
reduce runtime errors and therefore may restrict some mapping changes.  Note
that using the Dependency Injection pattern to manage state between Asynchronous
Operations removes the need for most parameter passing.}.  Changing the handling
Asynchronous Operations enables re-ordering the sequence of Asynchronous
Operations to service a request.

To ease debugging and improve developer understanding of the application, the
mapping configuration of \texttt{continuationId}  to \texttt{operationId} may be
graphical.  The Asynchronous Operations are represented as nodes with the
continuation mappings being directed lines between these nodes.  Due to the
similarity of configuration with service orchestration, this can be identified
as Operation Orchestration\footnote{Operation orchestration may also be
identified as function, procedure or method orchestration depending on the
implementing language.}.


\subsection{Related Patterns}

Thread Injection explained later in this paper provides a means for
prioritization and cancellation of the Asynchronous Operations.

The Dependency Injection pattern \cite{ioc} may be utilised to manage
dependencies for the Asychronous Operations.  The context managing the lifecycle
of dependencies within the Dependency Injection pattern may be aligned to the
Proactor Initiator lifecycle.  This allows dependencies for the Asynchronous
Operations to be specific to the request being serviced.  It also allows the
state/resources within these dependencies to be managed within the lifecycle of
servicing the request.  The continuation mapping configuration may also have
qualifying attributes that further scope dependency contexts.

As continuations asynchronously invoke Asynchronous Operations, they need not
only be invoked by Asynchronous Operations. Figure \ref{fig:DC_interface}
illustrates a possible interface that can be injected into dependencies to
invoke an Asynchronous Operation\footnote{No \texttt{continutionId} is necessary
as may inject multiple instances representing the different continuations.}. 
This enables dependencies to effectively become Active Objects
\cite{active-object} when necessary\footnote{The web server HTTP(S) sockets
would for example typically be implemented using Dependency Continuations.}.

\begin{figure}[tp]
\begin{verbatim}
    interface DependencyContinuation {
        void doContinuation(Object parameter);
    }
\end{verbatim}
\caption{Injected interface for a dependency to invoke a continuation (Active Object)}
\label{fig:DC_interface}
\end{figure}


\subsection{Known Usage}

Continution Injection can be considered an implementation of the Actor Model
\cite{actors} as it adheres to the principles of the Actor Model.  The
Asynchronous Operation is the actor.  The asynchronous communication between
Asynchronous Operations decouples the continuation argument (message) from the
sending Asynchronous Operation (actor).  The \texttt{operationId} provides an
address for an Asynchronous Operation (actor).  The provided
\texttt{continuationId}s restricts the Asynchronous Operations (actors) that may
be used.

Systems integrated with a queuing infrastructure are heavy weight
implementations of the Continuation Injection pattern.  The continuation is the
queue's client interface with the queue infrastructure providing the necessary
indirection to map the handler (Asynchronous Operation) of a message
(continuation argument).

Continuation Injection can also be considered a form of continuation-passing
style \cite{continuations} except that the continuation is injected rather than
passed as a parameter.  The added benefit of injecting the continuation is that
the Asynchronous Operation is free to depend on as many continuations as
necessary.  It also means that as the application evolves the Asynchronous
Operation encapsulates potential changes requiring different continuations.  The
indirection provided by the Continuation Injection pattern allows managing these
changes as configuration changes rather than code changes.

Subsequently event-driven architectures are an implementation of the
Continuation Injection pattern.  An Asynchronous Operation runs in a loop
waiting for events\footnote{The main loop Asynchronous Operation can be avoided
by mapping events directly to handling Asynchronous Operations.}.  On receiving
an event, the Asynchronous Operation invokes its appropriate continuations to
have the event handled by other Asynchronous Operations.  Note that event-driven
architectures are a more rigid implementation as Asynchronous Operations are in
most cases only synchronously invoked.

OfficeFloor \cite{officefloor} implements the Continuation Injection pattern and
will be discussed later in this paper as it also implements the Thread Injection
pattern to provide an Inversion of Control implementation.



\section{Thread Injection}


\subsection{Problem}

\textbf{Provide an algorithm for prioritization and cancellation of Asynchronous Operations.}


\subsection{Context}

The disadvantage of the Proactor pattern is that the ``Asynchronous Operation
Processor must be designed carefully to support prioritization and cancellation
of Asynchronous Operations'' \cite[p. 8]{proactor}.  Performance analysis of web
servers identifies the importance of this prioritization tuning
\cite{tuning-important,low-server-footprint,tuning-os-important}. The Proactor
pattern, however, does not provide algorithms for implementing its participants
and leaves the prioritization and cancellation of Asynchronous Operations to the
developer.  It does suggest, when not relying on the Operating System's
asynchronous I/O, to use a pool of threads to execute the Asynchronous
Operations but provides no further detail on implementing the pool of threads.


\subsection{Forces}

Tuning the prioritization is important to the performance of a Web Server.
Serving static web content follows a similar sequence of operations making the
use of a single thread pool sufficient.  In contrast, servicing dynamic content
has significantly varying operations.  Utilising a single thread pool to service
all dynamic content operations can result in tuning trade-offs that may result
in performance degredation of the Web Server during particular load profiles
(e.g. high load of requests for database data that are starving requests for
cached data of a thread).  Better isolation of operations is necessary to reduce
trade-offs in performance tuning.

Having an ability to cancel operations is important to avoid overloading the Web
Server.  As load increases on the Web Server, the resources available to the Web
Server will be exhausted causing delays in servicing requests and in some
scenarios cause the Web Server to crash (e.g. exhausting available memory). 
Operations must be able to be cancelled to reduce the load on the Web Server. 
However, only operations causing bottlenecks should be cancelled (e.g. a request
for cached data should not be cancelled if it is the database that is
overloaded).

Both prioritization and cancellation of operations is specific to the
application behaviour.  To enable portable implementations of Asynchronous
Operations, a standard interface is necessary that provides application specific
information regarding prioritization and cancellation of Asynchronous
Operations.


\subsection{Solution}

\textbf{Therefore, use multiple thread pools and based on meta-data of an Asynchronous Operation assign it to a particular Thread Pool.}

All Asynchronous Operations are constructed via extrinsic dependency management
\cite{ioc}.  The construction of the Asynchronous Operation is encapsulated in
the dependency injection factory and as such the Asynchronous Operation
Processor is provided a standard interface for all operations (Fig
\ref{fig:InjectionInterfaces}).  This enables for portable implementations of
Asynchronous Operations by developers.

The prioritization provided by the Thread Injection pattern is achieved by using
the \texttt{getRequiredDependencyTypes(\ldots)} method to obtain the extrinsic
dependency meta-data for an Asynchronous Operation\footnote{Dependency
Injection frameworks using qualification to identify dependencies of the same
type may return a type object containing both class and qualifier rather than
just a class.  The thread pool matching may then incorporate the qualifier.}.
The developer configures one or more thread pools responsible for Asynchronous
Operations with a particular type of dependency\footnote{Thread pools may be
associated with more than one dependency type.}.  The Asynchronous Operation is
then matched by its required dependency types to a Thread Pool responsible for
one or more of its dependency types\footnote{The \texttt{operationId} may also
be used for very fine grained mapping.}.  The \texttt{execute(\ldots)} method of
the Asynchronous Operation (Fig \ref{fig:InjectionInterfaces}) is then invoked
by a thread from the matching thread pool to execute the implementation of the
Asynchronous Operation.  This provides the necessary isolation of differing
Asynchronous Operations for better tuning of the Web Server.

For Asynchronous Operations not having dependencies (or dependencies of any
performance significance), a default Thread Pool is configured by the developer
for their execution.  This ensures all Asynchronous Operations are mapped to a
Thread Pool.  It also means that Thread Pools need only be configured for
dependencies requiring isolation.

The \texttt{cancel(Exception)} provides the means for the Asynchronous Operation
Processor to cancel the Asynchronous Operation.  The Asynchronous Operation
Processor will cancel new operations for a particular Thread Pool when queuing
the Asynchronous Operation for a thread will result in exceeding a particular
threshold\footnote{A sufficient threshold would be ensuring the wait time,
determined by a running average of execution time multiplied against the number
of Asychronous Operations currently in the queue, is below a certain time.}.
Each Thread Pool may have its own thresholds particular to its responsible
dependency types.  As Asynchronous Operations are mapped to particular Thread
Pools, this ensures only the appropriate operations are cancelled.

Once cancelled, the Asynchronous Operation Processor may discard the
Asynchronous Operation.  The implementation of the \texttt{cancel(Exception)}
method is specific to each Asynchronous Operation.  This is to allow appropriate
application behaviour to occur on cancelling Asynchronous Operations.


\subsection{Example}

Table \ref{tab:example_request_thread_pools} provides an example set of thread
pools for the motivating example.  A thread pool is configured for Asynchronous
Operations with a \texttt{Database connection}.  As the \texttt{Database
connection} is only available via Dependency Injection, all Asynchronous
Operations requiring I/O with the database must depend on the \texttt{Database
connection} and are subsequently mapped to be executed by a thread from the
\texttt{Database} thread pool.  The remaining operations have their own thread
pools allowing them to continue to be executed even if the database I/O is
causing thread starvation within its own thread pool.

\begin{table}[t]
\tbl{Example of assigning Asynchronous Operations to thread pools by dependency type}{%
\begin{tabular}{|l||l||l|}
\hline
\bfseries Thread Pool & \bfseries Dependency Type & \bfseries Asynchronous Operation \\
\hline
Network & Selector & Read data from socket \\
\hline
Database & Database connection & Retrieve data from database \\
\hline
Default & - & Parse HTTP request, \\
& & Dispatch HTTP request, \\
& & Validate client data, \\ 
& & Retrieve data from cache, \\
& & Render HTTP response, \\
& & Write HTTP response \\
\hline
\end{tabular}}
\label{tab:example_request_thread_pools}
\end{table}

The result for the motivating example is that the operations for servicing the
cached request can now be prioritized.  This can occur even if the database
driver has become non-responsive blocking all threads attempting to use a
database connection.  Furthermore, as the application becomes more complex with
an increasing number of downstream systems (e.g. Reverse 10K problem
\cite{reverse-ten-k-problem}), each downstream system's performance impacts may
be isolated by assigning it its own thread pool.  This has requests requiring a
slow downstream system to be deprioritized, allowing other requests to be
serviced.


\subsection{Consequences}

Thread Injection provides the implementating algorithm for the Proactor
pattern's Asynchronous Operation Processor participant by using multiple Thread
Pools to prioritise and cancel Asynchronous Operations.

Improved tuning of the Web Server is possible by the isolation provided by using
multiple Thread Pools.  Tuning the Thread Pools (such as restricting the number
of threads or changing the pool's thread nice values) allows prioritizing
threads and subsequently prioritizing groups of related Asynchronous Operations.

As each Thread Pool is executing Asynchronous Operations for a particular
dependency (or set of dependencies), this allows for adaptive resource
management and admission control regarding the dependency \cite{seda}.  This
enables both the number of threads and dependencies to be dynamically altered to
improve throughput.  However, when maximum throughput is reached additional
Asynchronous Operations above this threshold can be cancelled.

To improve performance of runtime decisions, the mapping of Asynchronous
Operation to Thread Pool may be cached.  As the dependencies for each
Asynchronous Operation is static, at application start up time the Asynchronous
Operation Processor may preprocess and cache the mapping of Asynchronous
Operations to thread pools to reduce runtime decision overheads.  This
pre-mapping of Asynchronous Operations may also provide warnings where
dependencies of an Asynchronous Operation make it possible to map the
Asynchronous Operation to multiple thread pools.  Different conflict mapping
resolutions may be employed, however ordering the thread pools and assigning
Asynchronous Operations based on first match is a sufficiently adequate
algorithm.

From the perspective of the Asynchronous Operation, the developer is able to
configure which thread pool will execute each Asynchronous Operation.  This
effectively injects the thread for execution in a similar way to injecting a
dependency for use.


\subsection{Related Patterns}

The Thread Injection pattern utilises information provided by the Dependency
Injection pattern.  The Thread Injection can be used in isolation of the
Dependency Injection pattern by mapping each Asynchronous Operation directly to
a Thread Pool and using implicit dependencies.  This however involves increased
configuration for the developer and may become invalid should Asynchronous
Operations change their dependencies as the application evolves.  It is
therefore recommeded to use Thread Injection in combination with Dependency
Injection to map Asynchronous Operations by dependencies to Thread Pools to
reduce configuration and mapping errors.

Utilising Thread Injection in combination with Continuation Injection allows
reducing thread context switching of the application.  As Continuation Injection
allows Asynchronous Operations to be synchronously invoked, the thread may be
borrowed to avoid the need for a thread context switch.

The Thread Pool pattern \cite{thread-per-request} is used to reduce overheads of
thread management for improved efficiency in execution of its responsible
Asynchronous Operations.  The implementation of the Thread Pool may be specific
to the dependency.  For example, the Thread Pool may contain multiple threads
for concurrent execution of Asynchronous Operations, a single thread for serial
execution of Asynchronous Operations or even no threads and execute Asynchronous
Operations by borrowing the thread to reduce thread context switching.


\subsection{Known Usage}

The Thread Injection pattern can be considered a style of cohort scheduling
\cite{cohort} that groups operations with similar dependencies and infers from
that similar functionality.  However, Thread Injection works at the application
scheduling level and allows use of any Operating System thread scheduling
algorithms.

The Staged Event-Driven Architecture (SEDA) \cite{seda} provides an
implementation of the Thread Injection pattern without the use of the Dependency
Injection pattern.  SEDA directly maps operations to a stage and subsequently a
Thread Pool.  The SEDA pipeline however has increased thread context switching
as the stage boundaries are hard disallowing threads to be borrowed.

Dependency capsules \cite{dependency-capsules} follows the idea of isolating
operations requiring dependencies to specific thread pools.  It however requires
a thread context switch back to a main thread for executing operations without
dependencies.

OfficeFloor \cite{officefloor} implements the Thread Injection pattern and will
be discussed later in this paper as it also implements the Continuation
Injection pattern to provide an Inversion of Control implementation.




\section{Web Server implementation}

This section discusses using the Thread Injection and Continuation Injection
patterns in implementing a Web Server.


\subsection{Servicing requests and managing URLs}

For web servers, URL continuations \cite{url-continuation} are used to invoke
the first Asynchronous Operation for servicing the request\footnote{A similar
approach may be taken by other User Interface types (such as a rich GUI) with
the user event being mapped to the first Asychnronous Operation.}.  A URL may be
associated to an Asynchronous Operation by developer configuration.  This
Asynchronous Operation then becomes the first operation to be invoked for
servicing a HTTP request for that URL.  This configuration may be included in
the Continuation Injection configuration (Operation Orchestration) as an
attribute of the Asynchronous Operation node.

Providing identifiers to Asynchronous Operations is also a convenient means to
ease maintenance of web pages.  Rather than embedding the URL in the web page,
the Asynchronous Operation identifier is used.  When the page is rendered for
the client the identifiers are replaced with the actual URLs.  This allows the
URLs to be changed without needing to change web pages.  It also enables using
configuration to change particular URLs to use secure channels (e.g. HTTPS)
without requiring changes to web pages.

Substituting the Asynchronous Operation URLs at page rendering time also enables
distributed load balancing.  A server may direct clients to a different server
by substituting URLs for Asynchronous Operations on another server. The
appropriate clients will then continue with the other server and subsequently
allow balancing the load across the distributed servers.


\subsection{Continuation for cancelling an Asynchronous Operation}

Cancelling the Asynchronous Operation is handled by the Asynchronous Operation
invoking a continuation.  On the \texttt{cancel(Exception)} method (Fig
\ref{fig:InjectionInterfaces}) being executed, the Asynchronous Operation will
clean up any resources and then invoke a continuation for an Asynchronous
Operation executed in another Thread Pool.  For a web server this Asynchronous
Operation could for example send a web page indicating the server is temporarily
busy or it may send a redirect to a less busy web server.

Each Asynchronous Operation may individually specify the continuation or a
default continuation may be configured across a set of Asynchronous Operations.
The default continuation will be mapped to an Asynchronous Operation that
interrogates the \texttt{cause} and undertakes appropriate further Asynchronous
Operations specific to the required application behaviour.  This is very similar
to \texttt{catch} blocks for handling an \texttt{Exception}.


\subsection{Implicit Thread}

When using the Thread Injection and Continuation Injection patterns together,
implicit threads may be used to reduce thread context switching.

The continuation may borrow the thread of the invoking Asynchronous Operation if
it results in being executed by the same thread pool.  The Proactor Pattern
stipulates that Asynchronous Operations ``must be performed without borrowing
the application's thread of control'' \cite[p. 8]{proactor} and this is the
focus of the Reactor Pattern \cite{reactor}.  Rather than dispatching back to
the same thread pool, the continued Asynchronous Operation may borrow the thread
to avoid the overhead of a thread context switch.

This same idea is also extended to the default thread pool for the Thread
Injection pattern.  Asynchronous Operations mapped to the default thread pool do
not have dependencies requiring isolation and are deemed cheaper to be executed
by borrowing the thread rather than incurring the cost of a thread context
switch.

The borrowed thread is the implicit thread.  Like an implicit continuation that
executes the next operation \cite{continuations}, the implicit thread executes
the next operation unless an explicit thread is required.  This can result in
the web server servicing the entire request without a thread context switch
should all the Asynchronous Operations involved not require an explicit thread
(e.g. web page content obtained from cache).

An implicit thread has similarities to a monadic thread \cite{monadic-thread}.
The Asynchronous Operations can be considered nodes in the lazy trace of the
monadic thread.  The advantage of an implicit thread\footnote{Beyond Operation
Orchestration being easier for the developer to understand than monad
programming.} is that Thread Injection allows prioritizing the execution of
blocking I/O nodes (Asynchronous Operations) by using explicit threads.  Monadic
threads can not prioritize blocking I/O nodes as they know little about them and
subsequently execute them within a single thread pool.


\subsection{Clustering/Distributing Asynchronous Operations}

As continuations asynchronously invoke Asynchronous Operations, the Asynchronous
Operation need not reside on the same server.  The injected continuation can be
configured to invoke an Asynchronous Operation on another server.  The
continuation may synchronously send the continuation arguments (e.g. HTTP
request) or the arguments may be asynchronously communicated (e.g.
queue).

Distributing Asynchronous Operations heterogeneously can also be undertaken by
configuring the responsible thread pool to reside on another server.  On
invoking the continuation, the continuation arguments are communicated to the
server\footnote{May be a cluster of servers.} containing the responsible thread
pool.  The dependency injection context state, to be reinstated on the other
server, may also be communicated with the continuation arguments depending on
thread pool mapping configuration.  Mapping the responsible thread pool to
another server is useful for example to co-locate certain Asynchronous
Operations geographically or have certain Asynchronous Operations run on
particular hardware.

The Internet is an example implementation that utilizes both Asynchronous
Operation heterogeneous clustering and the invoking of continuations to other
servers.  The URL continuation (e.g. by a user clicking on a link) is sent to
the server containing the thread pool (i.e. web server).  The web server
continues the processing by sending the HTTP response to the client web browser
(server to the user who may trigger further continuations).

The evolution to Cloud Computing can also be described as a form of Asynchronous
Operation heterogeneous clustering.  The number of servers containing a
particular thread pool are dynamically managed based on the number of
Asynchronous Operations to execute.  This dynamic management enables only the
required number of servers to be allocated for each thread pool.


\section{Motivating example resolved}

The \texttt{Retrieve data from cache} operation (Table
\ref{tab:example_request_operations}) from the motivating example will be used
to demonstrate resolution of the motivating example.  

As the Thread Injection and Continuation Injection patterns define the
algorithms for all Proactor pattern participants (except the application
behaviour of the Asynchronous Operation), only the Asynchronous Operation
developer implementation will be provided.  Fig
\ref{fig:Example_Method_Operation} shows the example developer implementation
code.  A generic Asynchronous Operation adapter implementation is used to
reflectively invoke the \texttt{retrieveData(\ldots)} method. It will:
\begin{enumerate}
  \item Obtain an instance of the \texttt{CacheOperation} via its context's \texttt{getDependency(\ldots)} method.
  \item Obtain both the \texttt{key}\footnote{\texttt{key} is a continuation argument from the previous Asynchronous Operation.} and \texttt{cache} again via the \texttt{getDependency(\ldots)} method.
  \item Instantiate a proxy implementation of the \texttt{CacheContinuation} interface that implements the \texttt{cacheMiss(\ldots)} method by invoking the \texttt{doContinuation(\ldots)} method. 
  \item Reflectively invokes the \texttt{retrieveData(\ldots)} with the above arguments.
\end{enumerate}

\begin{figure}[tp]
\centering
\begin{verbatim}
  interface CacheContinuations {
    void cacheMiss(String key);
  }

  class CacheOperation {    
    public Data retrieveData(String key, Cache cache, CacheContinuations continuations) throws IOException {
        Data data = cache.get(key);
        if (data == null) {
            continuations.cacheMiss(key);
            return null; // finish operation
        }
        return data;
    }
  }
\end{verbatim}
\caption{Example developer implementation code for an Asynchronous Operation}
\label{fig:Example_Method_Operation}
\end{figure}

Continuations from the \texttt{retrieveData(\ldots)} method are:
\begin{itemize}
  \item \texttt{cacheMiss(\ldots)} which will be mapped to the \texttt{Retrieve data from database} Asynchronous Operation.
  \item Implicit continuation (continuation invoked if no other continuation is invoked) which is mapped to the \texttt{Render HTTP response}\footnote{The return value from the method is used as the continuation argument.}.
  \item \texttt{IOException} that is mapped to an Asynchronous Operation providing an error message page.  It may also be mapped to the \texttt{Retrieve data from database} Asynchronous Operation to attempt to continue servicing the request.
  \item A default continuation is used should the Asynchronous Operation be cancelled.
\end{itemize}

Because the \texttt{cache} is in local memory it will not have a specific thread
pool configured.  The \texttt{retrieveData(\ldots)} method will subsequently be
executed by an implicit thread.

However, should the \texttt{cache} be remotely located requiring network access,
a thread pool can be assigned to it.  The \texttt{retrieveData(\ldots)} method
will be executed by a thread from this thread pool.

This example implementation of an Asynchronous Operation demonstrates resolution
of the issues within the motivating example.  The operation is a single distinct
method.  It specifies the next operation (e.g. skipping the \texttt{Retrieve
data from database} operation and going straight to the \texttt{Render HTTP
response} operation) by invoking the appropriate continuation.  Thread context
switching is reduced by using implicit threads.  An explicit thread can isolate the
\texttt{Retrieve data from database} operation.


\section{Inversion of Control}

Using all three injection patterns together (Dependency Injection, Thread
Injection and Continuation Injection) as implementing patterns to the Proactor
pattern forms the Inversion of Control pattern\footnote{Inversion of Control is
not just dependency injection as suggested by the Inversion of Control layer
\cite{ioc}.  It is better described as: Inversion of Control = Dependency
Injection + Thread Injection + Continuation Injection (or its shorter form: IoC
= DI + TI + CI).}.  For a method to be executed it requires:

\begin{itemize}
  \item an executing thread which Thread Injection inverts control;
  \item arguments for its parameters which Dependency Injection inverts control; and
  \item invoking the next operations which Continuation Injection inverts control.
\end{itemize}

Object-orientation therefore provides the implicit dependencies to the
method.  Explicit dependencies are injected as arguments to the method, while
object-orientation implicitly provides the instance/class references to the
method.  Functional programming can therefore be considered programming without
implicit dependencies.

Furthermore, Object-orientation can focus on modelling the data and have its
methods constrain the changes in state.  This is similar to databases storing
data and constraining the changes in the data.  As application behaviour is
implemented in Asynchronous Operations, the application need not be constructed
only as a graph of objects.

As control may be inverted for all aspects of the method, it provides an
Inversion of Control pattern.  This has potentially made the Asynchronous
Operation the software equivalent of a \textit{brick}\footnote{Objects do not
define the dimensions of thread and continuations providing only part of the
ingredients to a building block (brick).}.  The Asynchronous Operations have
standard interfaces for all their dimensions (dependencies/state, thread and
continuations) providing a standard mechanism for developers to weave the
\textit{bricks} (Asynchronous Operations) together to create the equivalent of
\textit{walls}, \textit{buildings} and further complex structures.


\section{Drawbacks}

The Thread Injection and Continuation Injection patterns have provided limited
improvement regarding the Proactor pattern being hard to debug.  While the
patterns have not directly addressed the Proactor issue of being hard to debug,
they do follow the trend of popular modern web servers by encapsulating
developer code within Asynchronous Operations.  However, the introduction of
dependencies maintaining state between Asynchronous Operations executed by
different threads leaves the possibility for dependencies to be non-thread safe
causing difficult to identify thread synchronization bugs.  Note that as
application logic is contained in Asynchronous Operations, this enables better
re-use of dependencies which improves their quality and subsequently reduces the
risk of these synchronization bugs.


\section{Known Uses}

OfficeFloor \cite{officefloor} is the only known framework implementing both the
Thread Injection and Continuation Injection patterns.  OfficeFloor also
implements the Dependency Injection pattern to provide an Inversion of Control
implementation.  OfficeFloor identifies Asynchronous Operations as
Jobs\footnote{Task is the adapted interface within a Job for application
developers to implement.} which originates from OfficeFloor's modelling of
application architecture after the way work is processed within an
office\footnote{This is where the name OfficeFloor is derived. The co-ordination
of executing Jobs occurs on the OfficeFloor.}.  Through developing OfficeFloor,
the author identified the Thread Injection and Continuation Injection patterns
along with the subsequent Inversion of Control pattern.


\section*{Acknowledgment} I thank my wife Melanie for her patience and support
of me developing OfficeFloor on top of my day job.  If she was anyone else
OfficeFloor would not have been built and this work would not have resulted from
OfficeFloor.  I also thank my good friend Matthew Brown for being a sounding
board to many of my ideas.

I am also grateful for the wise shepherding by Veli-Pekka Eloranta to ensure
this paper succinctly presents the Thread Injection and Continuation Injection
patterns.


\bibliographystyle{style/acmlarge}
\bibliography{tici}

\end{document}
