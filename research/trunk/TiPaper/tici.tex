%% OfficeFloor - http://www.officefloor.net
%% Copyright (C) 2013 Daniel Sagenschneider
%%
%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%%
%% While this document is not a program, it conveys the underlying design 
%% of OfficeFloor (it is the expression of how to implement the ideas of 
%% Thread Injection, Implicit Thread, Continuation Injection, Operation 
%% Orchestration, Inversion of Control) and as such any program derived from 
%% the contents (expression) of this document is considered conveying 
%% (copying/modifying) the OfficeFloor expression and is therefore subject 
%% to the licensing of OfficeFloor.




%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[prodmode]{style/acmlarge}

% Include packages
\usepackage{listings}
\usepackage{caption}


% Metadata Information
\acmVolume{V}
\acmNumber{N}
\acmArticle{A}
\articleSeq{S}
\acmYear{YYYY}
\acmMonth{0}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{style/algorithm2e}
\SetAlFnt{\algofont}
\SetAlCapFnt{\algofont}
\SetAlCapNameFnt{\algofont}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}
\renewcommand{\algorithmcfname}{ALGORITHM}

% Page heads
\markboth{D. Sagenschneider}{Software Design based on Patterns within the Office}


\title{Software Design based on Patterns within the Office}
\author{DANIEL SAGENSCHNEIDER \affil{OfficeFloor, daniel@officefloor.net}}

\begin{abstract}
OfficeFloor is a middleware framework that bases its design on the patterns
occurring within the office.  Using the proven patterns from the office has
improved the performance tuning and reduced the coupling of existing middleware
design patterns.  Furthermore, the patterns have provided inversion of control
to build applications bottom-up.  This bottom-up approach to building
applications better suits modern development methodologies, such Agile, that
evolve application architectures upwards.
\end{abstract}

\category{D.2.11}{Software Architectures}{Patterns}
\category{D.2.3}{Coding Tools and Techniques}{Object-oriented programming}
\category{D.2.6}{Programming Environments}{Graphical environments}

\terms{Design, Performance, Standardization}
\keywords{Inversion of Control, Responsible Thread Pool, Task Orchestration}

\acmformat{Sagenschneider, D. 2013.Software Design based on Patterns within the Office.}

\copyr{Copyright 2013 is held by the author}

\begin{document}

% Configure Graphics package
\graphicspath{{./pdf/}}
\DeclareGraphicsExtensions{.pdf}

% Configure Listings package
\lstset{language=Java}

% Configure Captions package (listing small font)
\captionsetup[lstlisting]{font=footnotesize}


\begin{bottomstuff}
This work is the result of the author's development of OfficeFloor.\\
Author: D. Sagenschneider; email: daniel@officefloor.net\\

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear this
notice and the full citation on the first page. To copy otherwise, to republish,
to post on servers or to redistribute to lists, requires prior specific
permission. A preliminary version of this paper was presented in a writers'
workshop at the 18th European Conference on Pattern Languages of Programs
(PLoP).
\end{bottomstuff}

\maketitle


%% TODO before final draft:
%%   - confirm SEDA adds/removes threads
%%   - go through GOF to confirm any alternate names
%%   - review previous paper for related implementations
%%   - fix up both sequence diagrams
%%   - include comment regarding Implicit Thread


\section{Introduction}

OfficeFloor~\cite{officefloor} is a middleware framework that models its
architecture on patterns occurring in offices.

The premise of this modelling is that business processes occurred manually
within offices before technology systems began automating tasks.  The manual
office processes are accepted by people and the patterns proven within many
business organisations.

This paper discusses these office patterns and how they provide improvement over
existing software design patterns.  The patterns presented are the patterns used
by OfficeFloor in its implementation as a middleware framework.
Usage patterns for developers to build applications with OfficeFloor is left to
future work.

To re-use the office patterns within software design, software concepts need to be
mapped to office concepts.  The following analogies are made to enable
re-using office patterns for software design:
\begin{description}
  \item[Thread] is mapped to the concept of a Person (Worker),
  \item[Method] is the functionality of a Task (particular step of a process),
  \item[Object fields] is the structured information managed within an office (e.g. form).
\end{description}

The patterns presented in this paper are discussed in three sections.  The three
sections respectively present the patterns for execution of tasks, collaboration
of tasks, and building processes from tasks.  Each section is written in two
parts.  The first part lists the office patterns and how they influence change
in the software design.  The second part of each section provides notes on
OfficeFloor's implementation of the patterns as a middleware framework.  This
paper assumes knowledge of existing software design patterns only for the
implementation notes.  The implementation notes may be skipped by those readers
only interested in the influence of the office patterns on software design.



\section{Patterns for execution of tasks}

The following patterns model the execution of methods after the way tasks are
undertaken within an office.  The implementation notes at the end provide
details on how to implement the combined patterns.


\subsection{\textsc{\textbf{team}}}

\subsubsection*{Context} Within an office work loads can be far above that
possible by a single person. This is resolved within an office by creating a
team of people to concurrently undertake the tasks.

Developers write code of a method (task) for a single thread (person).

\subsubsection*{Problem} Improving throughput of executing many methods.

\subsubsection*{Forces} Developer writes intuitive sequential code.

\subsubsection*{Solution} Use a pool of threads to execute the methods
concurrently.

\subsubsection*{Consequences} Having more people allows getting more tasks done.
Similarly having more threads allows more methods to be executed.

The people in the office need to coordinate so the tasks get done correctly and
efficiently.  This is similar of the concurrency issues occurring in executing
methods concurrently.

\subsubsection*{Related patterns} Also known as \textsc{thread pool}~\cite{thread-per-request}.

\subsubsection*{Notes} The \textsc{team} pattern is provided as an example to
demonstrate how the analogies in the introduction enable re-use of the office
patterns. See the \textsc{thread pool} pattern~\cite{thread-per-request} for a
detailed explanation of this pattern.



\subsection{\textsc{\textbf{categorise task}}}

\subsubsection*{Context} To assign a task to a particular team, a description of
the task is required to identify which team is responsible for undertaking the
task.  This description allows categorising similar tasks together to be
undertaken by a particular team for improved efficiencies.  For example, a
financial task is undertaken by the finance team.

\subsubsection*{Problem} Providing a description of the method (task) for it to be
categorised into a group of related methods.

\subsubsection*{Forces} The method name is free text and is unlikely to follow a
naming convention that allows parsing out a category.  Furthermore, the
developer should not have to write the description of the method.

\subsubsection*{Solution} Use the parameter types of the method to categorise
the method.  For example, all methods that declare a database connection
parameter are grouped into a category of tasks that are interacting with the
database.

For finer grained categorisation, use annotations on the parameter types.

\subsubsection*{Consequences} The method name is not required for categorising.
Also, the developer is not required to provide any more details except the
parameters the method requires.  However, methods that have unused parameters
may be incorrectly categorised.

\subsubsection*{Related Patterns} \textsc{responsible team} provides the thread
pools to execute the categories of methods.



\subsection{\textsc{\textbf{responsible team}}}

\subsubsection*{Context} There are different teams responsible for the differing
categories of tasks within the process.  For example, the financial team will do
the finance tasks and the software development team will do the software
development tasks.

Having this split in responsibility over the categorised tasks allows
specialising the team to their tasks.

\subsubsection*{Problem} Making the thread pool responsible for a particular
category of methods.

\subsubsection*{Forces} The thread pool name is free text and is unlikely to
follow a naming convention that allows parsing out its responsible task
categories.  Furthermore, the developer should not have to provide code to make
decisions over thread pool responsibilities.

\subsubsection*{Solution} Configure each thread pool with an attribute
containing the type that defines its responsible category of
methods\footnote{The thread pool may be configured with more than one type to be
responsible for multiple categories of methods.}. Methods are then executed by
the thread pool who's responsibility type matches one of the method's parameter
types (\textsc{categorise task} types).  A default thread pool is used if no
match occurs.

For example, configure the thread pool responsible for all database interaction
with the database connection type.  As each method is categorised by the
\textsc{categorise task} pattern, all methods requiring a database connection
are executed by this thread pool.

\subsubsection*{Consequences} There will always be a thread available in each
thread pool to execute their respective responsible category of methods. 
Subsequently, if there is a significant increase in the number of methods in one
category all threads do not become focused on these methods to the detriment of
the other categories of methods.

The threads in each thread pool are also specialised based on their responsible
category of methods (e.g. change in nice value, affinity to CPU).  However,
threads may be idle if no methods occur for their responsible category.

\subsubsection*{Related Patterns} Is a sequence on \textsc{team} to identify
the responsible categories of methods to execute.



\subsection{\textsc{\textbf{manage team size}}}

\subsubsection*{Context} As the number of tasks for a responsible team grows or
shrinks, the size of the team is altered to obtain optimal throughput.  For
example, near the end of the financial year the finance team will be increased
in size for the additional number of financial year end tasks.  The software
development team, however, would not be changed in size as the development tasks
stay the same in number.

\subsubsection*{Problem} Obtain optimal throughput execution of methods by a
thread pool.

\subsubsection*{Forces} Having too few threads will under utilize the hardware
and not provide optimal throughput.  Having too many threads will cause
excessive thread-context switching and exhaustion of available resources (e.g.
memory) which will decrease throughput.

\subsubsection*{Solution} As each thread pool is responsible for a particular
dependency (resource), use adaptive resource management~\cite{seda} to manage
the number of threads within each thread pool.

Adaptive resource management (from the Staged Event Driven Architecture
\cite{seda}) monitors the number of tasks and their execution time and
adds/removes threads and resources to achieve optimal throughput by the thread
pool (stage).

\subsubsection*{Consequences} The thread pool size will dynamically grow/shrink
based on its load of responsible methods to execute.  This, however, does
require a small overhead in monitoring the execution of methods.



\subsection{\textsc{\textbf{do it yourself}}}

\subsubsection*{Context} Certain tasks are more efficient to be undertaken
yourself without having to hand them off to another person.  If every task along
the process had to be undertaken by a different person, it would create
significant communication overheads that would negatively impact the efficiency
of the office.  Therefore, within an office many tasks are undertaken by the
current person involved in the process.

Assigning a method to a thread pool requires a thread-context switch to execute
the method.  Having to thread-context switch for execution of each method is
inefficient and will degrade performance of the application.

\subsubsection*{Problem} Avoid thread-context switching to execute each method.

\subsubsection*{Forces} Each category of methods will be executed by a
particular responsible thread pool.  Stepping between these categories causes
different responsible thread pools to be used that requires a thread-context
switch.  However, many methods in the process are cheaper to be executed by the
current thread of control than the incurred cost of a thread-context switch
(i.e. easier to do yourself).

\subsubsection*{Solution} Use a responsible thread pool that has no threads.
The method is executed immediately by the thread of control that registers the
method with the thread pool (i.e. borrows the thread of control).

\subsubsection*{Consequences} Categories of methods are executed by the current
thread of control and subsequently do not incur a thread-context switch.

\subsubsection*{Related Patterns} Is a sequence on the \textsc{responsible team}
to reduce thread-context switching.  It is also similar to the \textsc{reactor}
pattern~\cite{reactor} in reusing the thread of control.



\subsection{\textsc{\textbf{team too busy}}}

\subsubsection*{Context} When there is a very large number of tasks to complete,
teams will not be able to complete all their tasks within the required period of
time.  The teams may be increased in size to cope with the additional tasks.
However, at a certain point there are too many tasks and the team will not take
on new tasks.

The thread pool queues methods for execution when all threads of the pool are
exhausted.  At a certain point the queue becomes too long that new methods added
to the queue will not be executed within a reasonable period of time.

\subsubsection*{Problem} Stop the thread pool taking on new methods so it may
cope with the current load of methods.

\subsubsection*{Forces} The thread pool will sequentially execute all methods
added to its queue.  When the number of methods registered for execution is
continually more than the number of methods able to be executed, the queue
grows.  At a certain point the time between registering a method and the actual
execution of the method is so far apart that the resulting method execution is
no longer relevant.  Execution of these methods then results in wasted use of
threads and a non-responsive application.

\subsubsection*{Solution} Use admission control~\cite{seda} for each responsible
thread pool.  Admission control will at a certain queue size disallow further
methods from being registered.

\subsubsection*{Consequences} The thread pool will execute all methods that are
registered.  For methods not registered, \textsc{escalation} enables alternate
methods to be undertaken by another less busy thread pool (e.g. for a web server
this could be responding with a server temporarily busy page).

\subsubsection*{Related Patterns} Uses \textsc{escalation} to handle cancelled
(not registered) methods.



\subsection{Implementation notes for the task execution patterns}

\subsubsection*{Background}

Both the \textsc{thread-per-request} pattern \cite{thread-per-request} (basis of
many mainstream middleware designs\footnote{Example middleware using
\textsc{thread-per-request} is the popular web servers (Netcraft November 2012
survey) that serve dynamic web content by CGI/FastCGI with for example PHP scripts,
Microsoft's HTTP.sys/WAS, and JEE Servlets.}) and the \textsc{proactor} pattern
\cite{proactor} (basis of event-driven middleware designs) enable a different
thread of control for the execution of a request/task.  These patterns
allow for concurrent execution by utilising many threads.  For efficiencies the
\textsc{thread pool} pattern \cite{thread-per-request} is commonly used to pool
threads to reduce thread management overheads.

As identified by the \textsc{proactor} pattern, the threading ``must be designed
carefully to support prioritization and cancellation'' \cite[p. 8]{proactor} of
the execution of tasks.  However, both the \textsc{thread-per-request} pattern and
the \textsc{proactor} pattern do not define algorithms for
prioritisation and cancellation of tasks and leaves this to the developer.

Better isolation of tasks is necessary to reduce trade-offs in performance
tuning.  Utilising a single pool of threads to service all requests results in
tuning trade-offs that degrade performance of the server during particular load
profiles (e.g. high load of requests blocked on database I/O that are starving
requests for cached data of a thread).  This is further evident in the
performance analysis of web servers which identifies the importance of tuning
the server for a load profile
\cite{tuning-important,low-server-footprint,tuning-os-important}.

Having an ability to cancel tasks is important to avoid overloading the server. 
As load increases on the server, the resources available will be exhausted
causing delays in servicing requests and in some scenarios cause the server to
crash (e.g. exhausting available memory).  Tasks must be able to be cancelled to
reduce the load on the server.  However, only tasks causing bottlenecks should
be cancelled (e.g. a request for cached data should not be cancelled if it is
the database that is overloaded).


\subsubsection*{Implementation}

The \texttt{Task} (Listing \ref{lst:TaskExecutionInterfaces}) is the object that wraps
the method to provide a standard interface for execution of methods.  This
enables for a single \texttt{TaskExecutor} implementation (Listing
\ref{lst:TaskExecutionInterfaces}) to execute differing methods.

To execute a method the client code invokes \texttt{executeTask(\ldots)}
(Listing \ref{lst:TaskExecutionInterfaces}) with the identifier of the desired
\texttt{Task} (method).  The \texttt{TaskExecutor} uses the
\texttt{DependencyInjectionFactory} to construct the \texttt{Task}
and the dependencies for the \texttt{Task} (i.e. the parameters for the method
wrapped by the \texttt{Task}).  The \texttt{TaskExecutor} then assigns the
\texttt{Task} for execution by one of the many developer configured thread pools
(\textsc{team}).  Figure \ref{fig:ExecuteComponentSequenceDiagram} provides a
sequence diagram of executing a \texttt{Task}.

\lstset{caption=Task execution pattern interfaces.  The task collaboration patterns in the next section build on these interfaces to enable collaboration of the \texttt{Task}s.}
\begin{lstlisting}[float,label=lst:TaskExecutionInterfaces]

    interface Task {
        void execute(); 
        void cancel(Exception cause);
    }

    interface TaskExecutor {
        void executeTask(String taskId);
    }

    interface DependencyInjectionFactory {
        Task createTask(String taskId);
        Type[] getRequiredDependencyTypes(String taskId);
    }
\end{lstlisting}


\begin{figure}[!t]
\centering
\includegraphics[width=6in]{ExecuteComponentSequenceDiagram}
\caption{Sequence diagram of invoking \texttt{executeTask(\ldots)} (Listing \ref{lst:TaskExecutionInterfaces}).  The \texttt{Task} is executed by one of the responsible thread pools configured by the developer.}
\label{fig:ExecuteComponentSequenceDiagram}
\end{figure}

The \texttt{getRequiredDependencyTypes(\ldots)} (Listing
\ref{lst:TaskExecutionInterfaces}) method provides the categorisation of the
\texttt{Task}.  As the arguments to the method are supplied to its wrapping
\texttt{Task} by \textsc{dependency injection}~\cite{ioc}, the
\texttt{getRequiredDependencyTypes(\ldots)} method uses the \textsc{dependency
injection} configuration\footnote{OfficeFloor uses qualification to distinguish
dependencies of the same type and returns a type object containing both class
and qualifier.  The thread pool matching then incorporates the qualifier.} to
identify the required parameter types of the method within the \texttt{Task}
(\textsc{categorise task}).

The prioritisation tuning is achieved by use of responsible thread pools.  The
developer configures thread pools that are each responsible for \texttt{Task}s
with a particular type of dependency\footnote{Thread pools may be associated
with more than one dependency type.}.  To execute the \texttt{Task}, the
\texttt{Task} is matched by its dependency types to a thread pool responsible
for the dependency type\footnote{The \texttt{taskId} may also be used for very
fine grained responsibility.} (\textsc{responsible team}).  The
\texttt{execute()} method (Listing \ref{lst:TaskExecutionInterfaces}) is then
invoked by a thread from the matching thread pool to execute the \texttt{Task}.
This provides isolation of differing \texttt{Task}s to their respective
responsible thread pool for improved tuning of the server\footnote{The task
execution patterns are collectively identified as the software pattern
\textsc{thread injection}.  This is because the thread being chosen to execute
the method is undertaken in a similar way to the selection of dependencies by
the \textsc{dependency injection}~\cite{ioc} pattern.}.

For \texttt{Task}s not having dependencies (nor dependencies of any performance
significance), a default thread pool is used for their execution.  This ensures
all \texttt{Task}s are mapped to a thread pool.  It also means that thread pools
need only be configured for dependencies requiring isolation (i.e. all
\texttt{Task}s using the dependency are isolated to a particular thread pool for
execution).

To improve performance of runtime decisions the mapping of \texttt{Task} to
thread pool is cached.  As the dependencies for each \texttt{Task} is static, at
system start up time the \texttt{TaskExecutor} preprocess and caches the mapping
of \texttt{Task} to thread pools to reduce runtime decision overheads. 
Conflicts in methods being able to be mapped to multiple responsible thread
pools is resolved by ordering the thread pools and assigning \texttt{Task}s
based on first match.

To achieve further efficiencies the implementation of each thread pool is
specific to its responsible dependency type.  For example, the thread pool may
contain multiple threads for concurrent execution of \texttt{Task}s with threads
added/removing based on the load of \texttt{Task}s (\textsc{manage team sizes}),
a single thread for serial execution of \texttt{Task}s, or no threads and
execute \texttt{Task}s by borrowing the thread of control to reduce
thread-context switching (\textsc{do it yourself}).

The \texttt{cancel(\ldots)} method (Listing \ref{lst:TaskExecutionInterfaces})
enables the \texttt{TaskExecutor} to cancel the \texttt{Task}. The
\texttt{Task\-Executor} will cancel new \texttt{Task}s for a particular thread
pool when queuing the \texttt{Task} for a thread will result in exceeding a
particular threshold (\textsc{team too busy}).  Each thread pool has its own
thresholds particular to its responsible dependency type\footnote{A sufficient
threshold is ensuring the wait time, determined by a running average of the
\texttt{Task} execution time multiplied against the number of \texttt{Task}s
currently in the queue, is below a certain time.}.  As \texttt{Task}s are mapped
to particular thread pools, this ensures only the appropriate \texttt{Task}s are
cancelled.  Once cancelled the \texttt{TaskExecutor} may discard the
\texttt{Task}.  The implementation of the \texttt{can\-cel(\ldots)} method is
covered by the \textsc{escalation} pattern.


\subsubsection*{Consequences}

The isolation provided by using multiple thread pools enables improved tuning of
the server.  Tuning the thread pools (such as restricting the number of threads
or changing the pool's thread nice values) allows prioritising threads and
subsequently prioritising groups of related methods.

Furthermore, for systems requiring to integrate with many downstream systems
(e.g. the reverse 10K problem~\cite{reverse-ten-k-problem}), each downstream
system's performance impacts are isolated by assigning the downstream system's
communication dependency its own responsible thread pool.  This has requests
that require a slow downstream system to be queued on its responsible thread
pool, allowing other requests to be serviced by other thread pools.  Use of a
single thread pool, as per the \textsc{thread-per-request}
pattern~\cite{thread-per-request}, would result in thread starvation for the
other requests.

For low load servers where a single thread pool is sufficient, having multiple
thread pools causes increased complexity for developer configuration.  While
this provides the flexibility to focus the tuning of isolated categories of
tasks by tuning their mapped thread pool, it does put the burden on the
developer to understand thread related performance issues (e.g. costs related to
thread stack memory and thread-context switching) and the performance of the
dependencies (along with their related tasks).  In this case, a single
responsible thread pool is utilised.  Then as conditions of the application
change requiring improved performance tuning, additional responsible thread
pools are introduced to enable the required performance tuning of the
application.

OfficeFloor looses its ability to effectively prioritise and cancel tasks if the
task dependencies are too similar.  For example, all request handling for
dynamic content is likely to use a database connection.  While this will allow
isolation of requests for static content, it will not isolate requests for
dynamic content serviced from cached data rather than database data.  This is
because the request handler (task) will depend on the database connection to
retrieve the data if the data is not cached.  Request handling will, therefore,
need to be segmented into smaller tasks.  This is to reduce the occurrences of
sets of common dependencies between tasks, which results in grouping tasks all
onto the same thread pool.  The task collaboration patterns resolve this issue.


\subsubsection*{Related implementations}

JAWS~\cite{jaws} identified limitations in using a single concurrency model for
the application.  The JAWS framework enables multiple concurrency models to be
used by an application.  However, the concurrency models provided by the JAWS
framework are obtrusive to developer design requiring the developer to be
significantly involved with concurrency of the application.

The Staged Event-Driven Architecture (SEDA) \cite{seda} provides a similar
implementation to OfficeFloor without the use of the \textsc{categorise task}
pattern.  SEDA directly maps tasks to a stage and subsequently a thread pool.
However, the SEDA pipeline has increased thread-context switching as the stage
boundaries are hard, which disallows threads to be borrowed (i.e. not able to
use \textsc{do it yourself}).

OfficeFloor can be considered a style of cohort scheduling \cite{cohort}
that groups tasks with similar dependencies and infers from that similar
functionality.  However, OfficeFloor works at the application scheduling
level and allows the use of any operating system thread scheduling algorithms.

Capriccio~\cite{capriccio} utilises resource-aware scheduling of operating
system level resources.  To undertake this, Capriccio uses information based on
similar techniques to \textsc{categorise task}.  This results in improved
scheduling to better release resources to undertake new tasks.  However,
Capriccio is still subject to thread starvation for slow tasks by using only a
single thread pool.

Dependency capsules \cite{dependency-capsules} follows the idea of isolating
tasks that require dependencies to specific thread pools.  This is similar to
\textsc{responsible team}.  However, the dependency capsules require a
thread-context switch back to a main thread for executing tasks without
dependencies (i.e. can not use \textsc{do it yourself}).

Hop~\cite{hop} enables developers to provide code to dynamically decide the
concurrency model for tasks at runtime.  Having the developer provide this code
involves the developer significantly with the concurrency issues of the
application.  This required awareness of concurrency by the developer is
avoided by the performance tuning provided by responsible thread pools.



\section{Patterns for collaboration of tasks}

The following patterns model the collaboration of methods after the way tasks
collaborate within an office.  The implementation notes at the end provide
details on how to implement the patterns.


\subsection{\textsc{\textbf{hand-off}}}

\subsubsection*{Context} Teams hand-off to each other based on the category of
the next task.  For example, after financing a project the finance team hand-off
to the software development team to build the application.

Method invocations tightly couple the thread of control and disallow changing
the thread of control in invoking another method.

\subsubsection*{Problem} Enable changing the thread of control when invoking
another method.

\subsubsection*{Forces} The invoking of a method should still be intuitive for
the developer.

\subsubsection*{Solution}  Provide an interface as a parameter to the method.
Each method of the interface asynchronously invokes a respective target method.

\subsubsection*{Implementation note} A proxy implementation of the interface is
created by OfficeFloor and provided to the method by \textsc{dependency
injection}~\cite{ioc}.  The proxy implementation undertakes the asynchronous
invocation of the respective target method.

\subsubsection*{Consequences} The target method is asynchronously invoked by
another thread of control.  However, due to the asynchronous invocation no
return value is available from the invoked method.  Furthermore, each hand-off
incurs the cost of a thread-context switch.

\subsubsection*{Related Patterns} \textsc{record information} to provide return
values.



\subsection{\textsc{\textbf{escalation}}}

\subsubsection*{Context} Within an office a person will escalate issues to their
manager rather than the person handing-off to them.  However, the exception for
a method is thrown to the calling method.

\subsubsection*{Problem} Escalate an exception to a handling method rather than
the calling method.

\subsubsection*{Forces} Method exceptions follow the method calls back to an
appropriate \texttt{try\ldots catch} block for handling the exception.

\subsubsection*{Solution} Intercept the exception and \textsc{hand-off} the
exception to a handling method.

\subsubsection*{Consequences} The caller does not deal with exceptions from
\textsc{hand-off} method invocations.  This does mean the caller will not be
aware of failures in its invoked methods.  However, it is unreasonable to have
the caller responsible for all downstream issues in the process flow.

\subsubsection*{Related Patterns} \textsc{hand-off} is used to enable the
exception to be asynchronously handled by another method.



\subsection{\textsc{\textbf{define process flows}}}

\subsubsection*{Context} The process within an office is a sequence of tasks.
The next task in the process depends on what occurs with the current task.  The
process can be changed by altering the next task for each outcome of the current
task.

Method invocation prevents this flexibility as the code must be altered to
change the sequence that the methods are executed.

\subsubsection*{Problem} Change the execution order of methods without changing
code.

\subsubsection*{Forces} Method invocation is tightly coupled at the code level.

\subsubsection*{Solution} Use \textsc{hand-off} and via configuration map the
hand-off interface method to a handling method.  Furthermore, provide a hand-off
on completion of a method.  This completion hand-off is mapped to execute a next
method if no other hand-off is triggered (which includes \textsc{escalation}
hand-offs).

\subsubsection*{Consequences} Configuration maps the flow of methods rather than
being hard-coded within the method.  However, the resulting indirection will
make it difficult to follow the flow of the process.  Representing the
configuration graphically makes it easier and more intuitive to follow.  The
graphical configuration has tasks as nodes with hand-offs anchors on the task. 
The hand-off mapping configuration is directed lines from the hand-offs to their
respective handling task.

\subsubsection*{Related Patterns} \textsc{hand-off} is used to enable the
indirection for configuration mapping of hand-offs to handling methods.




\subsection{\textsc{\textbf{do your work}}}

\subsubsection*{Context} Within the process flow a team is assigned to execute a
sequence of tasks. Rather than passing the tasks around to different people in
the team, it is more efficient for one person to complete the sequence of tasks
without the cost of hand-offs.

\subsubsection*{Problem} Avoid the thread-context switch when the hand-off
results in a method being executed by the same responsible thread pool.

\subsubsection*{Forces} The hand-off is asynchronous.

\subsubsection*{Solution} Before registering the invoked method with its
responsible thread pool, check if the thread pool is the same responsible thread
pool of the current method.  If they are the same responsible thread pool
execute the invoked method synchronously (i.e. with the current method's thread
of control).

\subsubsection*{Consequences} Thread-context switching is reduced for sequential
methods of the same responsible thread pool\footnote{Combining \textsc{do your
work} with \textsc{do it yourself} provides the implicit thread of control.  The
implicit thread of control avoids thread-context switching in executing the
sequence of methods until an explicit thread (another responsible thread pool
containing threads) is required.}.

\subsubsection*{Related Patterns} Is a sequence on \textsc{hand-off} to reduce
thread-context switching.



\subsection{\textsc{\textbf{task complete}}}

\subsubsection*{Context} Within the office a person may need to know when their
handed-off tasks to other teams are complete.  For example a sales person will
need to get back to the customer when the finance team has the invoice ready.

\subsubsection*{Problem} Know when the handed-off method is complete.

\subsubsection*{Forces} Methods invoked by hand-offs are asynchronously executed by other
threads and there is no synchronous return from them to the calling method.

\subsubsection*{Solution} Provide a Future from the hand-off invocation to
indicate when the handed-off method is complete\footnote{As the handed-off
method may invoke further hand-offs, the Future indicates when the resulting
tree of hand-offs is complete.}.

\subsubsection*{Consequences} The Future provides a polling mechanism to check
when the handed-off method is complete.  Subsequently a thread is required to
poll the Future to determine when complete.

On handing-off many methods this enables distinguishing which handed-off methods
are complete.

\subsubsection*{Related Patterns} The \textsc{pick up task again} pattern avoids
polling the Future.



\subsection{\textsc{\textbf{pick up task again}}}

\subsubsection*{Context} Notifying of when the handed-off tasks are complete allows
the calling team to get on with other work and return to the task when the
handed-off tasks are complete.  For example, the sales team can seek out other
customers and only get back in contact with a customer when the financial team
notifies them that an invoice is ready.

\subsubsection*{Problem} Notify the current method when a handed-off method is
completed.

\subsubsection*{Forces} The handed-off method is asynchronously invoked and there is
no synchronous return to indicate when it is complete.

\subsubsection*{Solution} Re-register the current method for execution again
when the handed-off method is complete\footnote{As the handed-off method may
invoke further hand-offs, the re-register only occurs when the resulting tree of
hand-offs is complete.}.

To simplify multi-threading issues the method is only re-registered once with
its responsible thread pool for re-execution.  There may be multiple hand-offs
that will result in multiple re-registering.  Having the method only registered
once for execution reduces multi-threading issues.  After execution of the
method, the method may again be registered for execution by further handed-off
method completions.

\subsubsection*{Consequences} There is no need to poll the Future of the
hand-off invocation.  On waiting on many handed-off methods, the method may be
executed many times as each hand-off method completes.  The \textsc{task
complete} pattern is used as a guard condition to only execute the functionality
once all appropriate handed-off methods are complete.

\subsubsection*{Related Patterns} \textsc{task complete} is used to indicate
which handed-off methods are complete.



\subsection{\textsc{\textbf{record information}}}

\subsubsection*{Context} Information is recorded so that later tasks in the
office can retrieve this information.  However, methods only use the arguments
supplied from the calling method\footnote{The method may also access implicit
references via its owning object.  However, this is to be avoided with the
\textsc{record information} pattern.}.

\subsubsection*{Problem} Enable the method to retrieve information from previous
methods other than its calling method.

\subsubsection*{Forces} Method invocation requires the caller to provide all
parameters to the invoked method.

\subsubsection*{Solution} Use \textsc{dependency injection}~\cite{ioc} to inject
cached dependencies as the arguments to the method.

\subsubsection*{Consequences} As the cached dependencies provide state, they
enable all downstream methods in the process to retrieve the state.

Making the dependency state mutable allows upstream methods awareness of changes
in state when executed again via \textsc{pick up task again}.

\subsubsection*{Related Patterns} Is a sequence on \textsc{dependency
injection}~\cite{ioc} to cache dependencies and inject them as arguments to the
method.  The pattern has many similarities to \textsc{flyweight}~\cite{gof}.



\subsection{\textsc{\textbf{complete the form}}}

\subsubsection*{Context} When handing-off to another team, the receiving team
will require certain information to carry on with the next task in the process.  To
ensure the receiving team has all the information necessary for the particular
hand-off, the handing-off team is required to complete a form.

For example, for the financial team to raise a software defect, the software
development team requires the financial team to fill in a ticket (form) with the
details regarding the defect.

\subsubsection*{Problem} Pass data to the handling method when the hand-off has
a standard interface.

\subsubsection*{Forces} The handling method invoked by the hand-off retrieves
its data via \textsc{record information} (cached dependencies).

\subsubsection*{Solution} Allow a single argument to be passed with the hand-off
that encapsulates the data to be passed.  The argument is made available to the
handling method as a dependency via \textsc{record information}.

\subsubsection*{Consequences} The handling method need not differentiate between
the hand-off passed argument and the dependencies obtained from \textsc{record
information}.

\subsubsection*{Related Patterns} Is a sequence on \textsc{hand-off} and
\textsc{record information} to enable the caller to pass data with the hand-off.



\subsection{\textsc{\textbf{contact us}}}

\subsubsection*{Context} It is inefficient in an office for all customers to
have to go through the front desk to interact with the business.  Teams within
the office create contact us details to allow engaging their processes by people
external to the office.

\subsubsection*{Problem} Handing-off to the first method in the process when not
provided a hand-off interface (as outside the office/application).

\subsubsection*{Forces} The interface to invoke a hand-off is only provided to methods
being executed within a task.

\subsubsection*{Solution} Provide a unique address (e.g. URL) that directly maps
to the initial method of the process.  Sending a request to this address
constructs a new instance of the addressed process and triggers the first task
in that process.

\subsubsection*{Consequences} Processes are triggered from outside the
application. Responses are achieved by \textsc{record information} providing the
data for a response\footnote{\textsc{record information} also provides
access to the client connection to send the response.}.

\subsubsection*{Related Patterns} Is a sequence on \textsc{hand-off} to enable
external applications to hand-off to this application.



\subsection{Implementation notes for the task collaboration patterns}

\subsubsection*{Background}

Both the \textsc{thread-per-request} pattern \cite{thread-per-request} (basis of
many mainstream middleware designs) and the \textsc{proactor} pattern
\cite{proactor} (basis of event-driven middleware designs) impose tight
coupling on the collaboration of tasks (objects wrapping the execution of a
method).  The \textsc{thread-per-request} pattern enables invoking tasks by
synchronous methods, which is intuitive for developers \cite{proactor}.
In contrast, the \textsc{proactor} pattern enables asynchronously invoking a
constructed task by registering it for execution by another thread of control
(allowing to execute tasks concurrently).  In both patterns, they tightly couple
the collaboration of tasks as the \textsc{thread-per-request} pattern must have
the caller provide the thread of control and the \textsc{proactor} pattern must
have the caller construct the invoked task.

The \textsc{thread-per-request} pattern and \textsc{proactor} pattern further
tightly couple collaboration of tasks by the caller being required to handle
exceptions.  The caller may not be appropriately responsible to handle a
resulting exception and this should be handled by another task.


\subsubsection*{Implementation}

The task collaboration implementation builds on the task execution
implementation.  On executing a \texttt{Task} (object wrapping the method) the
\texttt{Task} is provided a \texttt{TaskContext} (Listing
\ref{lst:TaskCollaborationInterfaces}).

\lstset{caption=Task collaboration pattern interfaces.}
\begin{lstlisting}[float,label=lst:TaskCollaborationInterfaces]
    interface Task {
        void execute(TaskContext context);
        String[] getHandOffIds();
        String[] getStateIds();
    }

    interface TaskExecutor {
        Future executeTask( String taskId 
                          , Object parameter
                          , DependencyContext context);
    }

    interface TaskContextFactory {
        TaskContext createTaskContext( String taskId
                                     , Object parameter
                                     , DependencyContext context);
    }

    interface TaskContext {
        Object getState(String stateId);
        Future doHandOff(String handOffId, Object parameter);
        void handleException(Exception exception);
        void setComplete(boolean isComplete);
    }

    interface DependencyInjectionFactory {
        Type[] getRequiredDependencyTypes(String dependencyId);
        DependencyContext createDependencyContext();
    }
    
    interface DependencyContext {
        Object getDependency(String dependencyId);
    }

    interface Office {
        Future doProcess( String initialTaskId
                        , Object initialTaskParameter);
    }
\end{lstlisting}

\begin{figure}[!t]
\centering
\includegraphics[height=7.4in]{DoContinuationSequenceDiagram}
\caption{Sequence diagram of invoking \texttt{doHandOff(\ldots)}.}
\label{fig:DoContinuationSequenceDiagram}
\end{figure}


For the method within the \texttt{Task} to collaborate with other methods it
defines a hand-off interface (Listing \ref{lst:Example_Method_Task} provides an
example hand-off interface).  The \texttt{Task} wrapping the method creates a
proxy implementation of the hand-off interface.  The proxy implementation wraps
the \texttt{TaskContext} (Listing \ref{lst:TaskCollaborationInterfaces}) and
invokes \texttt{doHandOff(\ldots)} with the invoked interface method name as the
\texttt{handOffId} (\textsc{hand-off}).  As the \texttt{handOffId}s are static
for each \texttt{Task}, developer configuration provides the hand-off mapping to
the respective handling \texttt{Task}\footnote{OfficeFloor enhances the
\texttt{getHandOffIds()} method to also return the argument types that the
\texttt{Task} will provide on each of the hand-offs.  OfficeFloor also enhances
\texttt{getStateIds()} to provide the expected type the \texttt{Task} requires
for each \texttt{stateId}. Providing this type information enables the hand-off
argument to be type validated against the handling \texttt{Task}'s required
parameter type.  This reduces runtime errors by providing type validation of the
\textsc{define process flows} configuration.}.  Figure
\ref{fig:DoContinuationSequenceDiagram} provides a sequence diagram of invoking
a \texttt{Task} via the \texttt{doHandOff(\ldots)} method.

The \texttt{TaskContextFactory} (Listing \ref{lst:TaskCollaborationInterfaces})
constructs the \texttt{TaskContext}.  The \texttt{TaskContextFactory} centrally
manages the hand-off (\texttt{handOffId}) mapping to target \texttt{Task}
(\texttt{taskId}).

To avoid relying on \texttt{Task}s to define hand-offs, each \texttt{Task} has
an implicit hand-off.  The implicit hand-off is triggered on completion of the
\texttt{Task} should no other hand-offs be invoked.  This enables configuring a
sequence of \texttt{Task}s as sequential steps of a process.

The hand-off triggers the \texttt{TaskExecutor} to register a \texttt{Task} with
its responsible thread pool for asynchronous execution.  A \texttt{Future} is
returned from this registration to indicate when the handed-off \texttt{Task} is
completed (\textsc{task complete}).  The \texttt{TaskExecutor} is also notified
of completion of the \texttt{Task}.  This enables the \texttt{TaskExecutor} to
re-register any \texttt{Task}s waiting on the \texttt{Future} (\textsc{pick up
task again}).  \texttt{Task}s flag they need re-registering by calling
\texttt{setComplete(\ldots)} (Listing \ref{lst:TaskCollaborationInterfaces})
indicating the \texttt{Task} is not complete.

A \texttt{TaskExecutor} instance is created per process instance.  This enables
the life-cycle of \texttt{Task}s to be aligned with the process\footnote{The
\texttt{TaskExecutor} implementation within OfficeFloor also models the software
concept of a thread.  The hand-off configuration mapping has an attribute
indicating whether the hand-off spawns a thread (new \texttt{TaskExecutor}).}.
It also enables the \texttt{TaskExecutor} to register \texttt{Task}s that are
executed on completion of the process.  For example, registering a \texttt{Task}
to send the response at the end of the process.

Each \texttt{Task} is constructed via the \textsc{dependency injection} pattern
\cite{ioc}.  The \texttt{Dependency\-InjectionFactory} (Listing
\ref{lst:TaskCollaborationInterfaces}) centrally manages the dependency
configuration for all \texttt{Task}s.  To enable sharing state between
\texttt{Task}s, the \texttt{Dependency\-InjectionFactory} creates a
\texttt{Depend\-ency\-Context} that caches the dependency instances for the
\texttt{Task}s.  As the dependency instances are re-used across \texttt{Task}s,
this shares state between the \texttt{Task}s (\textsc{record information}).
Furthermore, as the \texttt{Dependency\-Context} manages the life-cycle of
dependencies, it is aligned to the \texttt{TaskExecutor} life-cycle.
This enables both the dependencies of the \texttt{Task}s and the \texttt{Task}s
themselves to be specific to the instance of the process.

The \texttt{doHandOff(\ldots)} method does allow one argument to be passed to
the invoked \texttt{Task} (\textsc{complete the form}).  This is for more
intuitive development by passed state with the hand-off.  If multiple arguments
are required they are encapsulated into an object for passing.
To maintain loose coupling the invoked \texttt{Task} obtains the argument as
state (i.e. \texttt{getState(\ldots)} method in listing
\ref{lst:TaskCollaborationInterfaces}).  This is so the invoked \texttt{Task}
need not differentiate between dependencies and parameters (\textsc{record
information}).  The invoked \texttt{Task} may also ignore the handed-off
argument should it not depend on it.

The hand-off will borrow the thread of control of the calling \texttt{Task} if
it results in being executed by the same thread pool.  Rather than dispatching
the \texttt{Task} back to the same thread pool, the \texttt{TaskExecutor}
borrows the thread to execute the next method (\textsc{do your work}). This
avoids the overhead of a thread-context switch.

Exceptions from the methods are handled by being mapped to a \texttt{handOffId}.
The \texttt{Task} invokes \texttt{handle\-Excep\-tion(\ldots)} with the
exception from the method.  The \texttt{handleException(\ldots)} method is
implemented by mapping the exception type to a \texttt{handOffId} and invoking
the \texttt{doHandOff(\ldots)} method with the exception as the argument
(\textsc{escalation}).  The developer configures hand-offs for specific
exception types (\textsc{define process flows}).  The developer will also
configure ''catch all'' hand-offs to handle exceptions from any \texttt{Task} to
ensure all exceptions are handled (e.g. handling of the runtime non-checked
exceptions).

Integrating with code not contained in \texttt{Task}s does not allow access to
the \texttt{TaskContext}.  The \texttt{Office} (Listing
\ref{lst:TaskCollaborationInterfaces}) provides an interface that allows code
not contained in a \texttt{Task} to invoke a hand-off to start a process.  The
returned \texttt{Future} indicates when all \texttt{Task}s of the process are
complete.  To retrieve results the \texttt{parameter} is used as a visitor
(\textsc{visitor} pattern \cite{gof}) and loaded with results by the invoked
\texttt{Task}s (\textsc{record information}).  The \texttt{initialTaskId} is
mapped to a unique URL for external triggering of the process (\textsc{contact
us}).



\subsubsection*{Example}

Listing \ref{lst:Example_Method_Task} shows an example method for retrieving
data from a cache.  The \texttt{Task} for the \texttt{retrieve\-Data(\ldots)}
method will:
\begin{enumerate}
  \item Obtain an instance of the \texttt{CacheOperation} via the \texttt{getState(\ldots)} method.
  \item Obtain both the \texttt{key}\footnote{\texttt{key} is a hand-off argument from the previous \texttt{Task}.} and \texttt{cache} again via the \texttt{getState(\ldots)} method.
  \item Instantiate a proxy implementation of the \texttt{CacheHandOffs} interface that wraps the \texttt{TaskContext}.  The proxy implements the \texttt{cacheMiss(\ldots)} method by invoking the \texttt{doHandOff(\ldots)} method. 
  \item Reflectively invoke the \texttt{retrieveData(\ldots)} method with the above arguments.
\end{enumerate}

\lstset{caption=Example developer code of a task for retrieving data from a cache\protect\footnotemark}
\begin{lstlisting}[float,label=lst:Example_Method_Task]
  class CacheOperation {
    public Data retrieveData(String key, Cache cache
                            , CacheHandOffs handOffs
                            ) throws IOException {
        Data data = cache.get(key);
        if (data == null) {
            handOffs.cacheMiss(key);
            return null; // finish task
        }
        return data;
    }
  }

  interface CacheHandOffs {
    void cacheMiss(String key);
  }
\end{lstlisting}
\footnotetext{\texttt{retrieveData} may also be a function should the implementing programming language support functions.}

Hand-offs from the \texttt{retrieveData(\ldots)} method are:
\begin{itemize}
  \item \texttt{cacheMiss(\ldots)} which is mapped to a \texttt{Task} to retrieve data from the database.
  \item Implicit hand-off which is mapped to the next \texttt{Task} in the process\footnote{The return value from the method is used as the hand-off argument.}.
  \item \texttt{IOException} which is mapped to a \texttt{Task} providing an error response.  It may also be mapped to a \texttt{Task} to retrieve the data from a database to attempt to continue the process.
\end{itemize}


\subsubsection*{Consequences}

The mapping of hand-off (\texttt{handOffId}) to \texttt{Task} (\texttt{taskId})
is contained within configuration.  This enables changing the invoked method
(\texttt{Task}) without changing the code of the methods.  Changing the handling
\texttt{Task} enables re-ordering the chained sequence of \texttt{Task}s that
are executed for the process.  This removes the invocation coupling of the
\textsc{proactor} pattern.  Furthermore, each \texttt{Task} is executed by a
thread from its responsible thread pool (i.e. potentially different thread). 
This removes the thread of control constraint imposed by the
\textsc{thread-per-request} pattern.

Understanding the collaboration of \texttt{Task}s would become difficult due to
the indirection involved.  However, the \textsc{define process flows}
configuration provides means for graphical tools to manage the configuration to
reduce this difficulty.  The tools graphically represent the \texttt{Task}s as
nodes with the hand-off mappings being directed lines between these nodes.  Due
to the similarity of this configuration with Service Orchestration this
graphical configuration is identified as Task Orchestration.

Furthermore, as \texttt{Task} are potentially executed by different threads of
control, the stack trace automatically provided by the
\textsc{thread-per-request} pattern no longer reflects the call hierarchy for
the process.  This can make it more difficult to debug issues.  However, the
\texttt{TaskExecutor} records the tree of \texttt{Task}s invoked so that the
tree can be traversed back to the root to identify the sequence of hand-offs to
the \texttt{Task} throwing the exception.  The whole tree can also be reported
to aid the developer in debugging the cause of the issue.

Functions can also be used in place of methods.  When implementing
\texttt{Task}s with functions, the functions will not be pure.  As state is
shared between \texttt{Task}s by mutable state within dependencies, functions
will need to cause side effects (mutate state) to share state with other
\texttt{Task}s.



\subsubsection*{Related implementations}

OfficeFloor is a form of continuation-passing style \cite{continuations}.
The hand-off can be considered a continuation, as it is a ''goto'' for executing
another \texttt{Task} with a different thread (stack)\footnote{The task
collaboration patterns are identified collectively as the software pattern
\textsc{continuation injection}.  The name comes from the hand-offs
(continuations) being injected into methods in a similar way to the dependencies
of the \textsc{dependency injection}~\cite{ioc} pattern.}.  The benefit of
providing hand-offs through a \texttt{TaskContext} is that the \texttt{Task} is
free to depend on as many hand-offs as necessary, and not what the caller
provides.  It also means that as the application evolves the \texttt{Task}
encapsulates potential changes requiring different hand-offs.  The indirection
allows managing these changes as configuration changes rather than code changes.

The combined \textsc{do your work} pattern and \textsc{do it yourself} pattern
of OfficeFloor has similarities to a monadic thread \cite{monadic-thread}.  The
\texttt{Task}s can be considered nodes in the lazy trace of the monadic thread. 
The trace ends when another thread of control is required.  The advantage of
OfficeFloor\footnote{Beyond Task Orchestration being easier for the developer to
understand than monad programming.} is that the \textsc{responsible team}
pattern allows the execution of blocking I/O nodes (\texttt{Task}s) to be
prioritised.  Monadic threads can not prioritise blocking I/O nodes as they know
little about them and subsequently execute them within a single thread pool.

OfficeFloor is an implementation of the Actor Model \cite{actors} as it adheres
to the principles of the Actor Model.  The \texttt{Task} is the actor.  The
asynchronous communication between \texttt{Task}s decouples the hand-off
argument (message) from the sending \texttt{Task} (actor).  The \texttt{taskId}
provides an address for a \texttt{Task} (actor).  The provided
\texttt{handOffId}s restricts the \texttt{Task}s (actors) that may be used.




\section{Patterns for building processes}

The following patterns compose methods into composite functionality after the
way processes are constructed from tasks within an office.  The implementation
notes at the end provide details on how to implement the patterns.


\subsection{\textsc{\textbf{task defines itself}}}

\subsubsection*{Context} Within an office the task itself will define its
dependencies and when aspects are no longer its responsibility.  Providing a
fixed set of dependencies and fixed set of hand-offs to a person to achieve a
task will, unless a very simple task, result in the task being unsuccessful.  To
be successful the person executing the task will seek out the required
dependencies and other people necessary to complete the task.

Furthermore, when conditions change the task may require new dependencies and
new hand-offs.  Introducing these new dependencies and hand-offs should be
encapsulated by the task and not significantly impact its containing process.

The method signature is fixed by the caller of the method and not the
implementation of the method.  The caller provides all arguments to the method
and the thread of control to execute the method\footnote{The invoked method may
spawn new threads but unless the caller provides reference to existing thread
pools, the method will not be able to use them.}.

\subsubsection*{Problem} Let the method implementation define the method
signature and continue to enable the caller to invoke the method as the method
signature changes.

\subsubsection*{Forces} The caller of a method:
\begin{itemize}
  \item identifies the method by name,
  \item provides all arguments to the method,
  \item handles all exceptions from the method,
  \item executes the method with its thread of control.
\end{itemize}

\subsubsection*{Solution} Use \textsc{hand-off} and \textsc{complete the form}
to decouple the caller from the method signature.  To enable the method
implementation to define the method signature, use:
\begin{itemize}
  \item \textsc{define process flows} to have method define its name (\texttt{taskId}),
  \item \textsc{record information} to provide the arguments,
  \item \textsc{escalation} to handle exceptions, and
  \item \textsc{responsible team} (via \textsc{categorise task}) to specify the thread of control.    
\end{itemize}

\subsubsection*{Consequences} The caller is no longer coupled to the method
signature.  This allows the method signature to change without impacting the
caller.

The Task Orchestration visual representation of \textsc{define process flows} is
necessary to understand the flow of the application code, as the call
hierarchies can no longer be determined by method signatures.



\subsection{\textsc{\textbf{process defines itself}}}

\subsubsection*{Context} The process is constructed from tasks.  As the tasks
define themselves, the process is subject to the necessities of its containing
tasks.  The process, therefore, becomes the sum of all the dependencies and
hand-offs of its containing tasks.

Furthermore, determining whether it is a task or whether it is a process involving
multiple tasks executed by differing responsible teams is typically not
initially known.  Initially this may be determined correctly.  However, over
time conditions may change that cause a task to become more complex requiring
it to be transformed into a process involving many tasks and many responsible
teams (or vice-versa being transformed from a complex process to a simpler task).

Triggering a process within in an office is no different to triggering a task.
Like the task, the caller of the process is decoupled from the process.
\textsc{complete the form} is undertaken and a \textsc{hand-off} occurs to the
first task of the process.  Similar to the task, the process will
\textsc{escalate} issues and will \textsc{hand-off} to other processes/tasks as
necessary.

Therefore, within an office the process defines itself to achieve its
requirements.  The process is also interchangeable with a task depending on the
required complexity.

\subsubsection*{Problem} Enable the a process to define itself.  Furthermore, in
defining itself the process is to have a similar interface to a \texttt{Task} to
be interchangeable with a \texttt{Task}.

\subsubsection*{Forces} Adding new tasks to a process is similar to adding new
functionality to a method.  Adding new functionality to a method involves:
\begin{itemize}
  \item new dependencies for the method that need to be referenced from the functionality,
  \item new exceptions that may occur from the functionality, and
  \item a different threading model to efficiently undertake the functionality. 
\end{itemize}

\subsubsection*{Solution} Represent the process as a \texttt{Task} in the
\textsc{define process flows}.  The process is given its own \texttt{taskId}
that maps to the initial \texttt{Task} of the process\footnote{The process may
expose multiple \texttt{taskId}s to enable starting at different \texttt{Task}s
within it.}.  All hand-offs not mapped to a \texttt{Task} within the process
become the set of hand-offs for the process (this includes \textsc{escalation}).
All dependencies of the contained \texttt{Task}s (from \textsc{record
information}) becomes the set of dependencies for the process.

To reduce the set of dependencies for the interface of the process, the process
may define objects to fulfill dependencies for its contained \texttt{Task}s.  These
fulfilled dependencies are not included in the interface set of dependencies for
the process.

Also, to reduce the hand-offs for the interface of the process, hand-offs
from multiple contained \texttt{Task}s are mapped to a single hand-off exposed
from the process.

\subsubsection*{Consequences} As the process is interchangeable with a
\texttt{Task}, composite processes are built from other processes.  The
interface of a composite process is created in the same way as if it contained
\texttt{Task}s.

Having composite processes constructed from other composite processes requires
the graphical representation of the \textsc{define process flows} pattern (Task
Orchestration).  This is necessary for the developer to understand the flows
within the application, as adding composite processes is further indirection
that requires visual representation to comprehend.

The \textsc{categorise task} pattern of each contained \texttt{Task} within the
process (and composite processes) is still followed.  As the process is
constructed from only \texttt{Task}s, the process focuses only on functionality
and allows all its \texttt{Task}s to be executed by the \textsc{responsible
team} pattern.  Therefore, if the responsible thread pools are changed for the
application the execution of the \texttt{Task}s within the processes follow the new
threading model without requiring code nor configuration changes.  This enables
the threading model of the application to be tuned to the hardware it is running
on (e.g. single thread pool for a low powered single CPU device or multiple
specialised thread pools for high-performance multi-core hardware\footnote{Using
increasingly better hardware follows the analogy of growing the workforce of a
business.  The business starts out only as a small number of people doing many
categories of tasks to becoming a large number of people doing very specific
categories of tasks.}).



\subsection{\textsc{\textbf{automate only where appropriate}}}

\subsubsection*{Context} Automating all processes is costly to a business.  In
many cases, using manual processes is cheaper than the cost of automating them.
Furthermore, all processes may not be mature enough to be automated.  Automating
a process requires standardising the process, ensuring the dependencies of the
process are available and accessible, and catering to all the exceptions that
may occur within the process.

Designing a business top down forces all processes to be of at least
standardised maturity to understand their interrelationships within the whole of
the business.  Having to mature all processes to be standardised increases cost
and forces less mature processes to be standardised before they have been
proven.  As the processes inevitably mature within the business, they become
different to their forced up front standardisation.

Businesses, therefore, standardise their processes by re-use of proven
tasks/processes and only automate where appropriate (bottom-up approach).

Designing technology systems top-down is subsequently not in alignment to how
businesses evolve.

\subsubsection*{Problem} Design technology systems bottom-up.

\subsubsection*{Forces} The method puts the control at the higher-level layers
of the system design.  The higher-level layer caller tightly couples the method
signature that the lower-level layers must implement.  The lower-level layers
may not change the method signature without refactoring the higher-level layers
due to this tight coupling.

\subsubsection*{Solution} Use \textsc{task defines itself} to only build proven
tasks.  Then build only the standardised processes through \textsc{process
defines itself}.

\subsubsection*{Consequences} Using \textsc{task defines itself} and
\textsc{process defines itself} enables the design of technology systems to
automate only the mature processes within the business.  The less mature
processes are left undefined until they mature in the business.

This bottom-up approach to designing systems aligns both to the business
maturing and also modern development methodologies.  Modern development
methodologies, such as Agile, evolve the architecture upwards based on providing
value back to the business.  Therefore, only the processes that provide value
back to the business are built leaving the remaining processes manual (except
where there is necessary information capture for the processes of value, i.e.
\textsc{record information}).



\subsection{Implementation notes for the process building patterns}

\subsubsection*{Background}

Applications built with \textsc{layers} typically impose a top-down approach to
design.  ``The \textsc{layers} require and provide \textsc{explicit interfaces}
from and to each other, in a top-down manner, from the higher to the lower
\textsc{layers}'' \cite[p. 11]{ioc}.  The higher-level layer components (object
that wraps a method) define the variation points that are
``predefined points in the control and data flow which allow for modifying and
extending a component's behaviour'' \cite[p. 5]{ioc}.  A top-down approach is
required, as the higher-level layers control what variation points may be
implemented by the lower-level layers.

The components need to be composed within an architecture that is dictated by
the framework.  The framework ``will define the overall structure, its
partitioning into \ldots [components], the key responsibilities thereof, how the
\ldots [components] collaborate, and the thread of control'' \cite[p.26]{gof}.
Using the components within a framework, therefore, identifies the following
requirements of a component's \textsc{explicit interface}:
\begin{itemize}
  \item components must have a key responsibility;
  \item components must be able to collaborate with other components; and
  \item components require a thread of control.
\end{itemize}

The collaboration of components can further be defined as the following
requirements:
\begin{itemize}
  \item components must be able to invoke other components;
  \item components must be able to share state; and
  \item exceptions from components need to be handled.
\end{itemize}

Within frameworks, the method signature is the interface between components.
``The set of all [method] signatures defined by an object \ldots characterizes
the complete set of requests that can be sent to the object'' \cite[p. 13]{gof}.
As frameworks are composed of objects, the method signature defines the
interface between objects and subsequently components.

The method signature meets the requirements as it:
\begin{itemize}
  \item has a key responsibility identified by its name;
  \item may invoke other methods;
  \item shares state with other methods by arguments and return values;
  \item provides declaration of exceptions for handling; and
  \item can be executed by the thread of control.
\end{itemize}

The method interface is, however, subject to tight coupling.  The tight
coupling occurs from the invoking higher-level layer component having to:
\begin{itemize}
  \item define the method name;
  \item provide the necessary arguments;
  \item possibly use the return value;
  \item handle potential exceptions; and
  \item provide the thread of control to execute the method.
\end{itemize}

This tight coupling imposed by the method results in the hierarchical
\textsc{layers} architecture where variation points (\textsc{explicit
interfaces}) are controlled by the higher-level layers.  The higher-level layer
component provides a \textsc{template method} \cite{gof} which is the variation
point that lower-level layer components may extend.

Within a \textsc{layers} architecture having variation points defined by
\textsc{template method}s requires refactoring of the \textsc{template method}
to increase the variability of the lower-level layer components.  Increasing the
variability ``requires adapting the \textsc{explicit interfaces} between the
\textsc{layers} to stipulate the types of variation parameters'' \cite[p.
5]{ioc} to allow control over the lower-level layers by the higher-level layers.

Instead of attempting to define variation points at the higher-level layers to
cover all possible variations of the lower-level layers, control should be
inverted and given to the lower-level layers to define the variation points. 
However, given that \textsc{template methods} impose a top-down control over
variation points, another form of \textsc{explicit interface} is necessary for
lower-level layer components to provide bottom-up control over defining
variation points for the application.



\subsubsection*{Implementation}

\textsc{record information} enables the lower-level layer component to specify
the state (objects) it requires.  The lower-level layer component specifies its
required state (objects) via \texttt{stateId}s.  As the lower-level layer
retrieves its state via \textsc{record information}, the invoking higher-level
layer components need only provide the single optionally used argument
(\textsc{complete the form}).  This allows the lower-level layer component to
specify as many dependencies as is necessary.  It, therefore, gives the
lower-level layer component control over what state (dependencies) it
may depend on.

\textsc{categorise task} enables the lower-level layer component to specify its
thread of control.  By the the lower-level layer component having control over
specifying its required dependency types, the lower-level layer component may
specify additional dependencies to control which responsible thread pool will be
used to execute it.

\textsc{hand-off} enables the lower-level layer component to specify its
required collaboration by \texttt{handOffId}s.  The mapping of
\texttt{handOffId} to \texttt{taskId} (\textsc{define process flows}) enables
configuring the higher-level layer components for handling each required
hand-off by the lower-level layer component.  As the higher level-layer
component does not need to provide references to these handling components on
calling the lower-level layer component, the lower-level layer component may
specify as many hand-offs as are necessary for its required collaboration
variation points.  This gives the lower-level layer component control over its
collaboration variation points.

Exceptions from components are handled by \textsc{escalation}.  The
exception is mapped to a \texttt{handOffId} and subsequently mapped to a
handling component.  As the invoking higher-level layer component is decoupled
from having to handle the exceptions, the lower-level layer component is free to
control throwing as many exceptions as is warranted.

Using the office patterns provides the necessary inversion of control over
variation points as the lower-level layer component controls:
\begin{itemize}
  \item its name (\texttt{taskId}) which is decoupled from the invoking higher-level layer component invocation (\texttt{handOffId}) by \textsc{define process flows};
  \item which invocations (\texttt{handOffId}s) are necessary via \textsc{hand-off};
  \item what state (\texttt{stateId}s) is required by \textsc{record information};
  \item the types of exceptions that may be thrown by \textsc{escalation}; and
  \item the thread of control by \textsc{categorise task} specifying the \textsc{responsible team}.
\end{itemize}

Therefore, the \texttt{Task} interface (Listing
\ref{lst:TaskCollaborationInterfaces}) is the \textsc{explicit interface} of a
component that provides inversion of control for the the method signature. 
Rather than the caller defining the method signature, the implementation of the
method controls defining the method signature (\textsc{task defines itself}).

To manage the complexity of the application's functionality, OfficeFloor
modularises the \textsc{define process flows} configuration (Task Orchestration)
into sections.  Each section provides hand-off mapping configuration between
\texttt{Task}s and other contained sections (\textsc{process defines itself}).
The lower-level layer sections configure the \texttt{Task}s together.  The
higher-level layer sections configure these lower-level layer sections together.
As sections are configured from other existing sections, it creates a bottom-up
approach to building the application\footnote{OfficeFloor configures the
top-level sections within an office.  The office configuration enables weaving
\texttt{Task}s as aspects into the contained sections (identified as the
\textsc{administration} pattern).  The office configuration also provides
additional management over dependencies, such as demarcating transactions
(identified as the \textsc{governance} pattern). OfficeFloor then configures
these offices onto the office floor where the dependencies and responsible
thread pools are configured.  The office building (agent running on each server)
hosts each office floor as a separate operating system process.  These patterns
will be included in the future work of usage patterns to build applications with
OfficeFloor.}.

Furthermore, the top-down approach to designing an application requires a divide
and conquer approach over the entire scope of the application requirements.
Without understanding all the complexities, the design may not adequately meet
the business needs and require significant refactoring to align to business
needs.  OfficeFloor enables building only the mature processes bottom-up
(\textsc{automate only where appropriate}).  This removes the need to understand
all complexities as only understanding of the scope of each process to automate
is required.


\subsubsection*{Consequences}

Within \textsc{task defines itself}, object-orientation provides the implicit
state (dependencies) to the method within the \texttt{Task}.  Explicit
dependencies are injected as arguments into the method (\textsc{record
information}).  Having implicit references from object-orientation tightly
couples the methods and should be avoided in the implementing methods for
\texttt{Task}s.  Furthermore, as the application behaviour is implemented in
\texttt{Task}s via methods, the application is no longer constructed only as a
graph of collaborating hierarchical objects.

Using \textsc{process defines itself} enables bottom-up control over the design
of the application.  As the variation points are controlled by the
\texttt{Task}s, developers start by building the \texttt{Task}s first.  As
the \texttt{Task}s are less abstract, the developer is able to focus on more
concrete problems and provide only the necessary variation points to solve the
particular problem.  This avoids over engineering the design of the application.
 Furthermore, as the processes are built last, there is less need for large
initial top-down designs (\textsc{automate only where necessary}).

\textsc{process defines itself} also enables bottom-up evolution of the
application.  Within applications imposing top-down design, the
\textsc{explicit interface} (\textsc{template method}) between \textsc{layers}
needs to be refactored to account for required changes to increase the
variability of the lower-level layer as the application evolves \cite{ioc}.
Within bottom-up \textsc{process defines itself}, the \texttt{Task}s may
introduce new variation points.  As the \textsc{explicit interface} to invoke
the \texttt{Task} does not change, the higher-level layer calling code does not
require refactoring to evolve the application.




\section{Conclusion}

The use of proven patterns occurring within the office has highlighted and
resolved limitations in existing design patterns for middleware frameworks.  The
\textsc{responsible team} pattern and its related task execution patterns
provides improved performance tuning of the application.  The \textsc{define
process flows} pattern and its related patterns decreases the coupling between
methods to enable more flexible change.  Finally, using these patterns together
for the \textsc{task defines itself} pattern and its related patterns provides
inversion of control to enable building application's bottom-up.

As this paper covers the implementation patterns of OfficeFloor, future work
will describe the usage patterns for developers to build applications with
OfficeFloor.



\section*{Acknowledgment} 

I thank my wife Melanie for her patience and support of me developing
OfficeFloor.  If she was anyone else OfficeFloor would not have been built and
this work would not have resulted from OfficeFloor.  I also thank my good friend
Matthew Brown for being a sounding board to many of my ideas.

I am also grateful for the wise shepherding by Veli-Pekka Eloranta and the
feedback from the participants of EuroPlop 2013, especially the very informative
feedback by the participants of the Design and Architecture writer's workshop.


\bibliographystyle{style/acmlarge}
\bibliography{tici}

\end{document}
