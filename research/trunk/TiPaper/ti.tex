%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{article}

%% Improve hyphenation
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Thread Injection and Continuation Injection}
\author{Daniel Sagenschneider}
\date{}
\maketitle

\abstract{}
The Thread Injection and Continuation Injection patterns provide implementing
algorithms for the participants of the Proactor pattern to enable Inversion of
Control for executing threads and execution order of operations.  These patterns
combined with Dependency Injection provide a complete Inversion of Control
pattern.

\section{Introduction}

The proactor pattern \cite{proactor} is used as the basis of popular modern web
servers \footnote{TODO name servers as identified from the Netcraft 2012 survey}
to dispatch request handling (events) asynchronously to request handlers
(Asynchronous Operations).

The disadvantage of the Proactor pattern is that the ``Asynchronous Operation
Processor must be designed carefully to support prioritization and cancellation
of Asynchronous Operations'' \cite{proactor}.  When not relying on the Operation
System's asynchronous I/O, the Proactor Pattern does suggest using pooled
threads to execute the asynchronous operations.  Performance analysis of web
servers identifies the importance of tuning this correctly
\cite{tuning-important,tuning-os-important,low-server-footprint}.  The Thread
Injection Pattern presented in this paper focuses on addressing prioritization
of Asynchronous Operations by using multiple thread pools.

The Asynchronous Operation API has also become a single standard interface to
enable servicing dynamic web page content.  The discussion of the Proactor
Pattern focused on web servers providing static content with developers
implementing the Proactor Initiator.  Popular web servers however provide
dynamic web page content via developers implementing Asynchronous Operations to
service a request.  To enable portable implementations the Asynchronous
Operation interface has been standardised \footnote{CGI with for example PHP,
.NET TODO what is this?, JEE Servlet used by servers from the Netcraft 2012
survey}.

The nature of the Proactor Pattern is to enable using many Asynchronous
Operations in servicing a HTTP request.  For the popular Web Servers
standardising of the Asynchronous Operation interface however has focused on the
Proactor benefit of simplification of application synchronization by allowing
only one Asynchronous Operation to synchronously service the entire dynamic web
page content \footnote{JEE Servlet 3.x specification is acknowledging this by
introduction of the AsyncContext however requires the developer to be aware of
thread synchronization complexities}.  The Continuation Injection Pattern
presented in this paper focuses on addressing this by allowing multiple
Asynchronous Operations to be used for dynamic web page content. It also
provides the means for cancellation of Asynchronous Operations.

\section{Motivating Example}

TODO use Thread Injection tutorial as basis for example.
\begin{itemize}
  \item Thread Injection: talk about cache and database requests
  \item Continuation Injection: talk about splitting cache logic from database request 
\end{itemize}


\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Example operations for servicing a HTTP request from database and caches. The dependencies of each operation are also listed.}
\label{tab:example_request_operations}
\centering
\begin{tabular}{l||l||l}
\hline
\bfseries Database Operations & \bfseries Cached Operations & \bfseries Dependencies \\
\hline\hline
Read data from socket & Read data from socket & Selector, Socket \\
\hline
Parse HTTP request & Parse HTTP request & Data read \\
\hline
Dispatch HTTP request & Dispatch HTTP request & HTTP request \\
\hline
Validate client data & Validate client data & HTTP request \\
\hline
Retrieve data from cache & Retrieve data from cache & Client data, \\
(cache miss) & (cache hit) & Cache \\
\hline
Retrieve data from database & & Client data, \\
 & & Database connection \\
\hline
Render HTTP response & Render HTTP response & Database data \\
\hline
Write HTTP response & Write HTTP response & HTTP response, \\ 
 & & Socket \\
\hline
\end{tabular}
\end{table}


\section{Dependency Injection}

The naming of the Thread Injection and Continuation Injection pattern is because
of their close association to the Dependency Injection pattern.

The Dependency Injection pattern enables constructing objects using extrinsic
dependency information to load dependencies without the need of the client
requiring awareness of the dependencies \cite{ioc}.  This allows implementations
to be swapped without syntatic changes.

The Dependency Injection pattern therefore enables:
\begin{enumerate}
  \item A single interface for multiple implementations
  \item Meta-data about dependencies required for the implementation
  \item Means to provide one or more differing objects to the implementation
\end{enumerate}

These properties of the Dependency Injection pattern are important for the
patterns described in this paper:
\begin{itemize}
  \item Single interface is necessary for the Asynchronous Operations.
  \item Meta-data about dependencies provides Thread Injection the necessary information for dispatching Asynchronous Operations to the appropriate thread pool.
  \item Continuations encapsulating the Proactor Completion Handlers and Completion Dispatchers can be provided to Asynchronous Operations.
\end{itemize}

\section{Thread Injection}

The Thread Injection pattern addresses both the implementation of the
Asynchronous Operation Processor and providing an interface to provide
prioritization information between the Asychronous Operations and the
Asynchronous Operation Processor.

It's name is derrived from Asynchronous Operations having their executing thread
chosen (injected) for them by configuration similar to dependency injection.

As already mentioned, the Proactor pattern specifies that the Asynchronous
Operation API must be both portable and flexible.  While this applies to the API
between the Proactor Initiator and Asynchronous Operation, it also must apply to
the API between the Asynchronous Operation and Asynchronous Operation Processor
to decouple them.  This will enable portable developer implementations of
Asynchronous Operations (such as generating dynamic web page content). 

For the Thread Injection pattern, all Asynchronous Operations are constructed
via extrinsic dependency management \cite{ioc} allowing standard interfaces.
The construction of the Asynchronous Operation is encapsulated in the depenency
management factory.  This enables both the interfaces to the Proactor Initiator
and Asynchronous Operation Processor to be standardised.

Standardising interface between the Proactor Initiator and Asynchronous
Operation is not necessary for Thread Injection.  It is however necessary for
Continuation Injection discussed later in this paper.

The interface between the Asynchronous Operation and Asynchronous Operation
Processor is provided in Fig \ref{fig:AO_interface_AOP}.

\begin{figure}[!t]
\begin{verbatim}
    interface DependencyInjectionFactory {
    
        Type[] getRequiredDependencyTypes(String operationId);
        
        AsynchronousOperation createOperation(String operationId);
    }

    interface AsynchronousOperation {
    
        void execute(AsynchronousOperationContext context);
        
        void cancel(Exception cause);
        
        String[] getContinuationIds();
    }
\end{verbatim}
\caption[Caption for Code]{Asynchronous Operation interface for the Asynchronous Operation Processor}
\label{fig:AO_interface_AOP}
\end{figure}

The \texttt{execute()} method is invoked by the thread of the chosen thread pool
to execute the implementation of the Asynchronous Operation.  The
\texttt{AsynchronousOperationContext} parameter and \texttt{getContinuationIds}
method provides means for Continuation Injection explained later in this paper.

\subsection{Prioritizing Asynchronous Operations}

The prioritization provided by the Thread Injection pattern is achieved by using
the \texttt{getRequiredDependencyTypes(String operationId)} method to obtain the
extrinsic depenency management information \footnote{Dependency Injection
frameworks using qualification to identify dependencies of the same type may
return a type object containing both class and qualifier rather than just a
class object.}.

The developer configures one or more thread pools responsible for Asynchronous
Operations with a particular type of dependency. Table
\ref{tab:example_request_thread_pools} provides an example set of thread pools
for the motivating example.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Example assigning of thread pool to Asynchronous Operations by dependency}
\label{tab:example_request_thread_pools}
\centering
\begin{tabular}{l||l||l}
\hline
\bfseries Thread Pool & \bfseries Dependency & \bfseries Asynchronous Operation \\
\hline\hline
Network & Selector & Read data from socket \\
\hline
Database & Database connection & Retrieve data from database \\
\hline
Default & - & Parse HTTP request, \\
& & Dispatch HTTP request, \\
& & Validate client data, \\ 
& & Retrieve data from cache, \\
& & Render HTTP response, \\
& & Write HTTP response \\
\hline
\end{tabular}
\end{table}

As the \texttt{Retrieve data from database} operation is assigned to be executed
by its own thread pool, the Thread Injection pattern allows the remaining
operations to be undertaken.  This is because only the threads of the
\texttt{Database} thread pool may undertake the operations which incur database
blocking I/O.  The remaining operations have their own thread pools allowing
them to continue to be executed even if the database I/O is causing thread
starvation within its own thread pool.

The Thread Injection pattern can therefore be considered a style of cohort
scheduling \cite{cohort} to group operations with similar dependencies (and
inferring from that similar functionality).  It however works at the application
scheduling level and allows use of any Operating System thread scheduling
algorithms.  Furthermore, tuning the thread pools (such as restricting number of
threads or changing the pool's thread nice values) allows prioritizing threads and
subsequently Asynchronous Operations.

As the dependencies for each Asynchronous Operation is static, at application
start up time the Asynchronous Operation Processor may also preprocess the
mapping of Asynchronous Operation to Thread Pool to reduce runtime decision
overheads.  This pre-mapping of Asynchronous Operations may also provide
warnings where dependencies of an Asynchronous Operation may make it possible to
be mapped to multiple thread pools.  Different conflict mapping resolutions may
be employed, however ordering the thread pools and assigning based on first
match is a sufficiently simple and understandable algorithm.

The result is that the Asynchronous Operations for servicing the cached request
can now be prioritized even if the database is causing significant delays that
would other wise have caused thread starvation when only a single thread pool
for all Asynchronous Operations was employed.

From the perspective of the Asynchronous Operation, the developer is now able to
select which thread pool will execute each Asynchronous Operation.  This
effectively injects the thread for execution similar to injecting a dependency
for use.  Hence the name of the pattern, Thread Injection.


\subsection{Cancelling Asynchronous Operations}

The \texttt{cancel(Exception)} provides the means for the Asynchronous Operation
Processor to cancel the Asynchronous Operation.  Once invoked, the Asynchronous
Operation Processor may discard the Asynchronous Operation.

The implementaion of the \texttt{cancel(Exception)} is the responsibility of the
Asynchronous Operation as it will likely be specific to the operation's
implementation.  The Continuation Injection pattern explained later provides a
means to alleviate this from the Asynchronous Operation implementation.

As each thread pool is executing Asynchronous Operations for a particular
dependency (or set of dependencies), it allows for stage management and
admission control regarding the dependency \cite{seda}.  Both the number of
threads and dependencies may be dynamically altered to improve throughput. 
However when maximum throughput is reached, additional Asynchronous Operations
above this threshold can be cancelled.


\section{Continuation Injection}

Continuation Injection focuses on the algorithms behind the Proactor pattern's
Proactive Initiator, Completion Handler and Completion Dispatcher participants
to enable multiple Asynchronous Operations to be utilised in servicing HTTP
requests.

The Continuation Injection relies on providing the
\texttt{AsynchronousOperationContext} to the Asynchronous Operations (Fig
\ref{fig:AOC_interface}).  The \texttt{getDependency(\ldots)}
method provides lazy retrieval of extrinsically defined dependencies.  The
remaining methods are for Continuation Injection.

\begin{figure}[!t]
\begin{verbatim}
    interface AsynchronousOperationContext {
    
        Object getDependency(String dependencyId);
        
        Future doContinuation(String continuationId, 
                                Object parameter);
        
        void continueOperation();
    }
\end{verbatim}
\caption[Caption for Code]{Asynchronous Operation Context interface \footnotemark}
\label{fig:AOC_interface}
\end{figure}
\footnotetext{Integer identifiers may be used for fast array lookups rather than string comparisons}

The \texttt{doContinuation(\ldots)} method triggers the Proactive Initiator to
undertake an Asynchronous Operation.  The Proactive Initiator is aware of the
possible continuations of the Asynchronous Operation via the
\texttt{getContinuationIds()} method (Fig \ref{fig:AO_interface_AOP}).  As the
continuation identifiers are static for each Asynchronous Operation, developer
configuration provides the mapping to the respective handling Asynchronous
Operation.  To ease debugging and better developer understanding of the
application, the configuration may be graphical where Asynchronous Operations
are nodes and continuation mappings are directed arrows.

As the continuation is an asynchronous operation, it may use the returned
\texttt{Future} to determine when the sequence of triggered Asynchronous
Operations has completed \footnote{State is managed within the dependencies so
there is no return value available from the \texttt{Future}}.  This enables
process continuations \cite{process-continuation} to be spawned by repeatly
calling \texttt{doContinuation(\ldots)} to aid in resolving such issues as the
reverse 10K problem \cite{reverse-ten-k-problem}.

Furthermore as continuations result in Asynchronous Operations, they need not
only be invoked by Asynchronous Operations. Fig \ref{fig:DC_interface}
illustrates an interface made available to dependencies to invoke an
Asynchronous Operation.  This enables dependencies to effectively become Active
Objects \cite{active-object}.

\begin{figure}[!t]
\begin{verbatim}
    interface DependencyContinuation {
            
        void doContinuation(Object parameter);
    }
\end{verbatim}
\caption[Caption for Code]{Dependency Context interface}
\label{fig:DC_interface}
\end{figure}


The \texttt{continueOperation()} method enables executing the current
Asynchronous Operation again.  The Asynchronous Operation Processor may be
implemented to defer execution of an Asynchronous Operations until invoked
continuations by the Asynchronous Operation or any of its dependencies are
completed.  This for example allows deferring executing the Asynchronous
Operation again until an Operating System asynchronous operation completes -
which enables the use of the key aspect of the Proactor pattern.

Having the Asynchronous Operation Processor defer executing on the Asynchronous
Operation can be considered a form of continuation pass processing \textbf{TODO
find reference}.  The Asynchronous Operation may be . . . tidy up this explanation.

Continuation Injection therefore enables stringing together multiple
Asynchronous Operations to service the HTTP request.  The ability to externally
configure the mapping of continuation to handling Asynchronous Operation is
where the Continuation Injection name is derrived.

\subsection{Initial Asynchronous Operation to service a HTTP request}

For web servers, URL continuations \cite{url-continuation} are used to invoke
the first Asynchronous Operation in the string.  Asynchronous Operations may be
associated to a URL by developer configuration as the first operation to invoked
for servicing a HTTP request.  This configuration may be included in
continuation graphical configuration as an attribute of the Asynchronous
Operation.  

Providing identifiers to these Asynchronous Operations is also a convenient
means to ease maintenance of web pages.  Rather than embedding the URL in the
web page content, the Asynchronous Operation identifier is used.  When the page
is rendered for the client, the identifiers are replaced the with the actual
URLs.  This allows the URLs to be changed without needing to change web pages.


\subsection{Continuation for cancelling an Asynchronous Operation}

Cancelling the Asynchronous Operation by the Asynchronous Operation Processor is
handled by the Asynchronous Operation invoking a continuation.  On the
Asynchronous Operation Processor invoking the \texttt{cancel(Exception cause)}
method, the Asynchronous Operation will clean up any resources and then invoke a
continuation which should invoke an Asynchronous Operation for another thread
pool.

Each Asynchronous Operation may specifically specify the continuation, or a
default continuation may be provided.  The default continuation will be mapped
to an Asynchronous Operation that interrogates the \texttt{cause} and undertakes
appropration further Asynchronous Operations specific to the required
application behaviour.


\section{Implicit Thread}

When using the Thread Injection and Continuation Injection pattern together,
implicit threads may be used to reduce thread context switching.

The continuation may borrow the thread of the invoking Asynchronous Operation if
it results in execution by the same thread pool.  The Proactor Pattern
stipulates that Asynchronous Operations ``are performed without borrowing the
application's thread of control'' which is the focus of the Reactor Pattern
\cite{reactor}.  Rather than dispatching back to the same thread pool the
continued Asynchronous Operations may safely borrow the Asynchronous Operation
invoking thread to avoid the overhead of a thread context switch.

This same idea is also extended to the default thread pool for the Thread
Injection Pattern.  For an Asynchronous Operation not requiring any dependencies
for dispatching to a specific thread pool, the Asynchronous Operation is deemed
cheaper to be executed by the current Asynchronous Operation's thread than
incurring the cost of a thread context switch.

The borrowed thread is the implicit thread.  Like an implicit continuation that
executes the next operation \cite{continuations}, the implicit thread executes
the next operation unless a explicit thread is required.  This can result in the
Web Server servicing the entire request without a thread context switch should
no explicit threads be required for servicing the request (e.g. web page content
obtained from cache).


\section{Example implementation of an Asynchronous Operation}

As all participates (except the Asynchronous Operation) in the Proactor pattern
have specific algorithms, the following is an example of an Asynchronous
Operation implementation.  The \texttt{Retrieve data from cache} operation from
the motivating example will be used (Table
\ref{tab:example_request_operations}).

Fig \ref{fig:Example_Method_Operation} shows the developer implementation code. 
A generic Asynchronous Operation adapter implementation is used to reflectively invoke
the \texttt{retrieveData(\ldots)} method. It will:
\begin{enumerate}
  \item Obtain an instance of the \texttt{CacheOperation} via the \texttt{getDependency(\ldots)} method.
  \item Obtain the both the \texttt{key} and \texttt{cache} via the \texttt{getDependency(\ldots)} method \footnote{\texttt{key} is an argument from the previous operation}.
  \item Instantiate a proxy implentation of the \texttt{Continuation} interface that implements the \texttt{cacheMiss(\ldots)} by invoking the \texttt{doContinuation(\ldots)} method.  This also demonstrates injecting the continuation much like injecting a dependency. 
  \item Reflectively invokes the \texttt{retrieveData(\ldots)} with the above arguments.
\end{enumerate}

\begin{figure}[!t]
\begin{verbatim}

    interface CacheContinuations {

        void cacheMiss(String key);
    }

    class CacheOperation {
    
        public Data retrieveData(String key, Cache cache, 
                        CacheContinuations continuations)
                        throws IOException {
        	Data data = cache.get(key);
        	if (data == null) {
        	    continuations.cacheMiss(key);
        	    return null; // finish operation
        	}
        	return data;
        }
    }
\end{verbatim}
\caption[Caption for Code]{Example method used as an implementation of an Asynchronous Operation}
\label{fig:Example_Method_Operation}
\end{figure}

Continuations from the \texttt{retrieveData(\ldots)} method are:
\begin{itemize}
  \item \texttt{cacheMiss(\ldots)} which will be mapped to the \texttt{Retrieve Data from Database} Asynchronous Operation.
  \item Implicit continuation (continuation invoked if no other continuation is invoked) which is mapped to the \texttt{Render HTTP response} \footnote{The return value from the method is used as the argument}.
  \item \texttt{IOException} to be mapped to an Asynchronous Operation providing an error message page.  It may also be mapped to the \texttt{Retrieve Data from Database} Asynchronous Operation to attempt to continue servicing the request.
  \item A default continuation is used should the Asynchronous Operation be cancelled.
\end{itemize}

Because the \texttt{cache} is in local memory it will not have a specific thread
pool configured.  The \texttt{retrieveData(\ldots)} method will therefore be
executed by the implicit thread.

Should however the \texttt{cache} be remotely located requiring network access,
a thread pool can then be assigned to it.  The \texttt{retrieveData(\ldots)}
method will therefore be executed by a thread from this thread pool.  This
demonstrates injecting the Thread much like injecting a dependency.


\section{Inversion of Control pattern}

Using all three injection patterns together (dependency, thread, continuation)
as implementing patterns to the Proactor pattern forms the Inversion of Control
pattern.

For a method to be executed it requires:
\begin{itemize}
  \item A thread to execute it which Thread Injection inverts control
  \item Arguments for its parameters which Dependency Injection inverts control
  \item Next operations to invoke which Continuation Injection inverts control
\end{itemize}

And therefore all aspects may be inverted in control providing for a complete
Inversion of Control pattern.

\section{Drawbacks}

\emph{Hard to debug}: The Thread Injection and Continuation Injection Patterns
have not resolved the Proactor issue of being hard to debug.  Furthermore,
dependencies that are not appropriately thread safe can create very difficult to
identify bugs.

\section{Known Uses}

OfficeFloor \cite{officefloor} is the only known use of the Thread Injection and
Continuation Injection pattern.  It is hoped that by providing more awareness of
these patterns that adoption of these patterns will increase.


\bibliographystyle{style/IEEEtran}
\bibliography{ti}

\end{document}
