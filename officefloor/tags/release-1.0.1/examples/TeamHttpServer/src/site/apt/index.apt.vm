                                               -----------------------
                                              Team HTTP Server Example 
                                               -----------------------
					        Daniel Sagenschneider
                                               -----------------------

  <<Team Http Server Example>>

  OfficeFloor refers to a thread pool as a {{{/apidocs/net/officefloor/frame/spi/team/Team.html}Team}}.

  This example demonstrates the ability to assign a {{{/apidocs/net/officefloor/frame/spi/team/Team.html}Team}} (thread pool) to execute specific tasks.
  
  The application for this example provides encrypting of a letter.  The letter is encrypted by a database table providing mapping of the letter to an alternate letter.  The mapping is cached within the application to provide quicker lookups.  The database tasks of the application are executed by a separate {{{/apidocs/net/officefloor/frame/spi/team/Team.html}Team}}.
  
  The reason for separating the database tasks to be executed by another thread is to increase through put and responsiveness of the application.  Web servers hosting applications will typically have a single thread pool to service all requests.  Database I/O is blocking meaning that the thread is blocked while servicing the HTTP request.  Under heavy loads, all threads can end up in this blocked state and the web server has to queue remaining requests as no threads are available to service the requests.  Many requests for the web server are however for static content that is typically cached and only requires a few cpu cycles of a thread to service the request.  Increasing the number of threads causes increased lock contention and potential stavation from the cpu leading to degraded performance.  The answer is not in a single thread pool (or optimsing the scheduling of requests to service as this can lead to stavation and increased application complexity) but in creating further thread pools. 
  
  This example shows how OfficeFloor makes it simple for all database tasks to be executed by a separate thread pool leaving the HTTP request servicing thread pool free to service these smaller requests.
  
  {{{http://sourceforge.net/projects/officefloor/files/maven/maven2/net/officefloor/example/TeamHttpServer/${projectVersion}/TeamHttpServer-${projectVersion}-project.zip/download}Download Example Source}}
  
Code

  The following is the <<<main>>> method to run the application.

%{code-snippet|sh-params=highlight:[16,17,18,19]|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/TeamHttpServer.java}

  The leader follower team is a {{{/apidocs/net/officefloor/frame/spi/team/source/TeamSource.html}TeamSource}} implementation that is a pool of multiple threads following the leader follower pattern to reduce lock contention.  The above configured <<<Team>>> will have 10 threads to execute tasks assigned to it.

  The ability to determine database tasks are via the dependencies for the task.  Tasks wanting to interact with the database will need access to a <<<DataSource>>> and therefore any task depending on a <<<DataSource>>> to be database task.

  The {{{/apidocs/net/officefloor/plugin/autowire/AutoWireOfficeFloorSource.html}AutoWireOfficeFloorSource}} nature of the {{{/apidocs/net/officefloor/plugin/web/http/server/HttpServerAutoWireOfficeFloorSource.html}HttpServerAutoWireOfficeFloorSource}} provides the ability to specify which <<<Team>>> is responsibly for executing which task by the task's dependencies.  In this case, any task with a <<<DataSource>>> dependency will be executed by the leader follower team.  All other tasks are executed by the default <<<Team>>>, which in the case for the <<<HttpServerAutoWireOfficeFloorSource>>> is by default a {{{/apidocs/net/officefloor/frame/impl/spi/team/OnePersonTeamSource.html}OnePersonTeamSource}}.
    
* Template.ofp

  The following is the content of the template:

%{code-snippet|brush=xml|file=${basedir}/src/main/resources/Template.ofp}

  The addition to the template is to output the name of the thread executing particular tasks:
  
   * <<<encrypt>>> : encrypting the letter from cache (no database interaction required)
   
   * <<<retrieveFromDatabase>>> : retrieving the letter encrypting from the database
   
  This allows indicating that different threads (from different teams) are executing these tasks.

* Template class

  The first aspect of the template logic is to provide the values for the <<< $\{tag\} >>> entries.  
  
  Along with providing the values, the class is also annotated so that it is stored within the HTTP session.  This allows the simple <<<cache>>> field to be a cache of retrieved mappings from the database.

%{code-snippet|brush-autodetect=1|id=values|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/Template.java}

  The following provides the ability to specify the <<<displayCode>>> field: 

%{code-snippet|sh-params=first-line:25|brush-autodetect=1|id=setDisplayCode|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/Template.java}

  The {{{/apidocs/net/officefloor/plugin/section/clazz/Parameter.html}Parameter}} annotation is flag that the <<<LetterEncryption>>> is not a dependency to be provided by a {{{/apidocs/net/officefloor/frame/spi/managedobject/source/ManagedObjectSource.html}ManagedObjectSource}} but rather is passed from the previous task.  OfficeFloor provides this capability to allow tasks to communicate to each other.  OfficeFloor at start up ensures that the output argument type from the previous task matches the input parameter type of the task to reduce runtime issues.
  
  Initially nothing will be cached.  The following method will retrieve the mapping for the encrypting of a particular letter from the database and caches it.  As it has a <<<DataSource>>> dependency it will be executed by the leader follower team configured in the <<<main>>> method above. 

%{code-snippet|sh-params=first-line:29|brush-autodetect=1|id=retrieveFromDatabase|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/Template.java}
    
  Once the <<<LetterEncryption>>> is retrieved from the database it is returned from the above method.  As the above method is annotated to execute the <<<setDisplayCode>>> next, the returned <<<LetterEncryption>>> becomes the parameter for the execution of the <<<setDisplayCode>>> method.

  Finally is the handling method for the encrypt form submission: 

%{code-snippet|sh-params=first-line:55|brush-autodetect=1|id=encrypt|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/Template.java}

  The above method handles the HTTP request by determining if the letter encryption is cached.  Should it be cached, the cached <<<LetterEncryption>>> is returned as the parameter for the next task (<<<setDisplayCode>>> method).  On the other hand, if the letter is not cached the <<<retrieveFromDatabase>>> is triggered next (instead of <<<setDisplayCode>>>) to retrieve the encryption for the letter.
  
  Therefore depending on whether cached the execution flow of tasks is as follows:
  
   * Not cached
   
     [[1]] <<<encrypt>>> (executed by default team) does not find the letter within the cache, so triggers to retrieve from database (passing the particular letter to retrieve)
     
     [[1]] <<<retrieveFromDatabase>>> (executed by leader follower team) retrieves the letter encryption from the database along with caching it.  It then returns the <<<LetterEncryption>>> for the next task
     
     [[1]] <<<setDisplayCode>>> (executed by default team) specifies the <<<LetterEncryption>>> for display
     
     [[1]] template is rendered (by default team) for response to the client
     
   * Cached
   
     [[1]] <<<encrypt>>> (executed by default team) finds the letter within the cache and returns the cached <<<LetterEncryption>>> for the next task
     
     [[1]] <<<setDisplayCode>>> (executed by default team) specifies the <<<LetterEncryption>>> for display
     
     [[1]] template is rendered (by default team) for response to the client
     
  Though this is a simple example it does highlight that under heavy load that cached letter encryptions can still be serviced even if all database (leader follower) threads are blocked waiting on the database. 
  
* Remaining code

  The remaining code is included for completeness of this example. 

** datasource.properties
  
%{code-snippet|brush=plain|file=${basedir}/src/main/resources/datasource.properties}

** createDatabase method

%{code-snippet|sh-params=first-line:24|brush-autodetect=1|id=createDatabase|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/TeamHttpServer.java}

** EncryptLetter class

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/EncryptLetter.java}

** LetterEncryption class

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/example/teamhttpserver/LetterEncryption.java}

Unit Test

  The unit test requests the encrypting of a letter twice:
  
   * first time retrieving from database and caching
   
   * second time retriving from cache

%{code-snippet|brush-autodetect=1|id=test|file=${basedir}/src/test/java/net/officefloor/example/teamhttpserver/TeamHttpServerTest.java}

