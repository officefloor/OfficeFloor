~~~
~~ #%L
~~ Thread Affinity Tutorial
~~ %%
~~ Copyright (C) 2005 - 2020 Daniel Sagenschneider
~~ %%
~~ This program is free software: you can redistribute it and/or modify
~~ it under the terms of the GNU Affero General Public License as published by
~~ the Free Software Foundation, either version 3 of the License, or
~~ (at your option) any later version.
~~ 
~~ This program is distributed in the hope that it will be useful,
~~ but WITHOUT ANY WARRANTY; without even the implied warranty of
~~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
~~ GNU General Public License for more details.
~~ 
~~ You should have received a copy of the GNU Affero General Public License
~~ along with this program.  If not, see <http://www.gnu.org/licenses/>.
~~ #L%
~~~

                                               -----------------------
                                               Thread Affinity Tutorial 
                                               -----------------------
                                                Daniel Sagenschneider
                                               -----------------------

Thread Affinity Tutorial

  
  This tutorial looks at configuring an {{{/apidocs/net/officefloor/frame/api/executive/source/ExecutiveSource.html}ExecutiveSource}} to provide thread affinity for a web application.

  To demonstrate the thread affinity, the following simple application is used.

[./images/threadaffinity-screenshot.png] Thread Affinity screen shot.

  {{{https://github.com/officefloor/OfficeFloor/tree/master/officefloor/tutorials/ThreadAffinityHttpServer}Tutorial Source}}


  
*Thread Affinity

  Thread affinity binds the thread to only run on a particular CPU core.  The advantage of using thread affinity is that it can increase the CPU cache hits, as the thread will always be run on a particular core.  Increasing CPU cache hits reduces bus contention and improves performance of processing.
  
  However, thread affinity is not a silver bullet to improving performance.  There can be circumstances of cache sizes increasing causing the cache hits to drop.  However, in many cases it can provide an increased boost in performance to your applications (between 2 to 5 times faster).
  
  Always performance test to ensure thread affinity is providing your application the increased CPU cache hits and subsequent increased performance.


{{{/apidocs/net/officefloor/web/executive/WebThreadAffinityExecutiveSource.html}WebThreadAffinityExecutiveSource}}

  Thread affinity is not straight forward to implement.  However, OfficeFloor makes it simple via the {{{/apidocs/net/officefloor/web/executive/WebThreadAffinityExecutiveSource.html}WebThreadAffinityExecutiveSource}} (that uses {{{https://github.com/OpenHFT/Java-Thread-Affinity}OpenHFT}}).
  
  <<Please ensure you follow the instructions on {{{https://github.com/OpenHFT/Java-Thread-Affinity}OpenHFT}} to install the necessary native libraries for thread affinity to work.>>
  
  Then simply include the following on the class path:
  
%{snippet|id=tutorial|file=${basedir}/pom.xml|ignoreDownloadError=false}

  This will set up thread affinity for:
  
   - HTTP servicing threads
   
   - all teams (each team is split to run across the CPU cores with their threads bound to a particular core)
   
  The result of this is that the web request is serviced entirely on one CPU core.  This allows for improved CPU cache hits even if you require multiple threads (teams) to service the request.  All threads for servicing the request will be bound to the same CPU core.  This subsequently, in many cases, boosts your application performance - as each CPU core can act like it's own server without having to have <heavy weight> synchronising between the cores slowing application performance.



*Proving the Thread Affinity

  The tutorial outputs the name of the thread at the top of the page.  The thread name is comprised of:
  
   [[1]] The naming of the bound dependency

   [[1]] The CPU core that the thread is bound

   [[1]] Index of the thread within the thread pool
   
  As the invoking thread is bound to a CPU core on triggering the mock request, running the request multiple times should always have the same CPU core.
  
  The following test demonstrates the same CPU core always servicing the request.
  
%{snippet|id=tutorial|file=${basedir}/src/test/java/net/officefloor/tutorial/threadaffinityhttpserver/ThreadAffinityHttpServerTest.java|ignoreDownloadError=false}



*ExecutiveSource
  
  For further details on how you can control threads within an application see the {{{/apidocs/net/officefloor/frame/api/executive/source/ExecutiveSource.html}ExecutiveSource}}.  It is beyond this tutorial to explain it's full capabilities, however it is geared to following how the executives would manage personal in an office.



Next

  The {{{../ObjectifyHttpServer/index.html}next tutorial}} covers using Objectify for the Google App Engine DataStore.

