                                               -----------------------
                                         Thread Injection HTTP Server Tutorial
                                               -----------------------
					        Daniel Sagenschneider
                                               -----------------------

  <<Thread Injection Http Server Tutorial>>

  This tutorial demonstrates the ability to assign a thread pool to execute specific methods (i.e. thread injection).  OfficeFloor refers to a thread pool as a {{{/apidocs/net/officefloor/frame/spi/team/Team.html}Team}}.
  
  The example used for this tutorial is an encrypter for a letter.  A database table stores the encryption by mapping the letter to an alternate letter.  Once the letter encryption is looked up in the database it is cached to provide quicker subsequent lookups for that letter.  The example's web page is as follows and has been kept simple to focus on thread injection.

[./images/TeamHttpServer-screenshot.png] TeamHttpServer screenshot.
  
  The example displays the names of two threads to show the different thread pools (Teams) servicing the request.
  
   * thread to obtain cached letter encryption
   
   * thread (pool) to look up letter encryption within the database
   
  {{{http://sourceforge.net/projects/officefloor/files/maven/maven2/net/officefloor/tutorial/TeamHttpServer/${projectVersion}/TeamHttpServer-${projectVersion}-project.zip/download}Download Tutorial Source}}

  
Web Server Efficiency and Responsiveness

  The thread per request architecture of most web servers will typically have a single thread pool to service all requests.  Database I/O is typically blocking.  Under heavy loads all threads can end up blocked waiting on the database.  As the web server has no free threads, it queues further requests degrading the responsiveness of the web application.

  Most requests to a web server are for static cached content.  Having these requests wait behind longer database requests means non-optimal use of the web server.  The blocked threads leaves the web server's CPU idle.  Having an additional thread would allow the web server to continue servicing the static cached content requests.  This is especially relevant as the company's home page is usually static cached content and users have a low tolerance for slow web site responsiveness.  Also increasing the number of threads for cached content can cause lock contention and potential stavation resulting in degraded responsiveness. 
  
  Serving cached content is best by a single thread while database content is best by a pool of threads.  These two types of request are typically handled by most web servers with a single thread pool.  However increasing the efficiency and responsiveness of a web server is not acheived by increasing the number of threads but by increasing the number of thread pools.
  
  The example for this tutorial shows how OfficeFloor enables increasing the number of thread pools for efficient servicing of cached and database requests. 


Configuration

  The following is the <<<application.woof>>> configuration for the example application.

[./images/team-woof.png] application.woof configuration.

  The <<<DataSource>>> to the database is configured as follows.
  
%{code-snippet|brush=xml|file=${basedir}/src/main/resources/application.objects}

  With the following properties.
  
%{code-snippet|brush=plain|file=${basedir}/src/main/resources/datasource.properties}

  See the {{{../index.html}other tutorials}} for explanation of the above configuration.


* Thread Injection Configuration
  
  The thread injection configuration is contained in the <<<application.teams>>> file at the root of the class path.  For the example application it is as follows.
  
%{code-snippet|brush=xml|file=${basedir}/src/main/resources/application.teams}
  
  The leader follower team is a {{{/apidocs/net/officefloor/frame/spi/team/source/TeamSource.html}TeamSource}} implementation that implements the leader follower thread pool pattern to reduce lock contention.
  
  WoOF uses the method's dependencies to determine the type of functionality being undertaken by the method.  The method's dependencies give an indicator of what the method is likely to be doing.  In this case if the method requires a <<<DataSource>>> it is very likely that it will be doing blocking database I/O calls.  This means of classifying methods allows OfficeFloor to automagically use the appropriate thread pool to execute the method.  It is what OfficeFloor considers thread injection.

  All other methods are executed by the default <<<Team>>>.  Running stand-alone this would be the socket listener thread.
  
  Adding thread pools is optional and therefore the inclusion of the <<<application.teams>>> file is optional.  It is anticipated that threading will be configured closely to the dependencies available within an environment.  In many cases this will be handled by the environment deployment.  The file however is supported for extending WoOF web applications by customising the thread pools.



Code
  
  The following is the content of the template.

%{code-snippet|brush=xml|file=${basedir}/src/main/webapp/Template.woof.html}

  The following provides the values for the <<< $\{property\} >>> entries from the template logic.  

%{code-snippet|brush-autodetect=1|id=values|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/Template.java}
  
  Along with providing the values the class is also annotated so that it is stored within the HTTP session.  This allows the <<<cache>>> field to act as a cache across requests.  See the {{{../index.html}other tutorials}} for further details.
  
  The example application first tries the cache for the encrypted code.
  
%{code-snippet|brush-autodetect=1|id=cache|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/Template.java}

  Should the encrypted code be found in the cache it is passed as a parameter to the setter method.  The setter method keeps reference to the encrypted code for rendering the web page response.  See the {{{../index.html}other tutorials}} for explanation of this WoOF functionality.

  On not finding the encrypted code in the cache the above method triggers for it to be retrieved from the database.  The following method retrieves the encrypted code from the database.  The returned encrypted code is passed to the setter method for rendering to the web page.

%{code-snippet|brush-autodetect=1|id=database|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/Template.java}

  As the method has a <<<DataSource>>> dependency it is executed by the leader follower team.  This is reflected by the web page response showing different threads executing the cache and database methods.
     
  Though this is a simple example it does highlight that under heavy load that cached letter encryptions can still be serviced even if all database (leader follower) threads are blocked waiting on the database.

  
* Remaining code

  For completeness of the tutorial the remaining code for the example application is included below.

** Database Setup

%{code-snippet|brush-autodetect=1|id=tutorial|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/Setup.java}

** EncryptLetter

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/EncryptLetter.java}

** LetterEncryption

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/tutorial/teamhttpserver/LetterEncryption.java}



Unit Test

  The following unit test makes requests to encrypt a letter.

%{code-snippet|brush-autodetect=1|id=test|file=${basedir}/src/test/java/net/officefloor/tutorial/teamhttpserver/TeamHttpServerTest.java}

  As the same letter is requested, the
  
   * first request retrieves the encrypted code from the database (and caches it)
   
   * second request retrives it from the cache

