                                               -----------------------
                                            Interactive HTTP Server Tutorial 
                                               -----------------------
					        Daniel Sagenschneider
                                               -----------------------

  <<Interactive HTTP Server Tutorial>>
  
  This tutorial looks at handling a form submission.
  
  The below example for this tutorial will implement a simple form submission, validate a name was entered, and provide a message if successfully entered values.  The simple for for this tutorial is as follows:
    
[./images/InteractiveHttpServer-screenshot.png] InteractiveHttpServer screenshot.
  
  {{{http://sourceforge.net/projects/officefloor/files/maven/maven2/net/officefloor/tutorial/InteractiveHttpServer/${projectVersion}/InteractiveHttpServer-${projectVersion}-project.zip/download}Download Tutorial Source}}
  


Template.html

  The below is the content of the <<<Template.woof.html>>>.

%{code-snippet|brush=xml|file=${basedir}/src/main/webapp/Template.woof.html}

  
  

TemplateLogic Class

  The <<<Template.html>>> has its logic provided by the <<<TemplateLogic>>> class.
  
  The first aspect of this class is the annotation to indicate that it should be bound to the HTTP Session.

%{code-snippet|brush-autodetect=1|id=class|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  The annotation is a flag to WoOF that the <<<TemplateLogic>>> object for the page should be stored in the HTTP Session.  This will then make the list of items available across requests.  The class implements <<<Serializable>>> as must all objects bound to a HTTP session.
    
  As the items are now stored across HTTP requests, the items must be exposed for rendering to the template.  The below method  exposes the <<<Item>>> objects for being rendered.

%{code-snippet|brush-autodetect=1|id=items|sh-params=first-line:5|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  With the above method the template can be rendered to display the items.


* Handling a request for interactivity
  
  Initially there will be no items in the list so the page provides the form submission to add an item.  
  
  Looking back at the template the action url of the form is actually <<< #\{addItem\} >>> .  On submitting the form, OfficeFloor will invoke the below method via naming convention (same name).

%{code-snippet|brush-autodetect=1|id=addItem|sh-params=first-line:8|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  Notice that the method has a single parameter <<<Item>>>.  The <<<Item>>> class is annotated as follows which identifies to WoOF that the object should be loaded with the corresponding HTTP parameter values.
  
%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/Item.java}
  
  The following steps therefore occur on submitting the form:
  
   [[1]] an <<<Item>>> object is instantiated from its default constructor
   
   [[1]] form submission parameters are reflectively loaded onto the <<<Item>>> object by matching HTTP parameter name to setter method name, e.g. <<<description>>> to <<<setDescription(String description)>>>
   
   [[1]] the <<< Item >>> object is passed to the invocation of the <<< addItem >>> method as the parameter value

  This relieves writing plumbing code and allows focus on handling the values submitted by the user (in this case adding the item to the list).  It also makes for cleaner and easier to unit test code.
  
  Once the <<<addItem>>> method returns, WoOF will by default re-render the template back to the user.  It is possible to direct flow to other templates however this is beyond the scope of this tutorial.
  
  Along with adding an item to the list the template also provides the ability to clear the list of items.  Clicking on the <<< #\{clear\} >>> link invokes the following method.

%{code-snippet|brush-autodetect=1|id=clear|sh-params=first-line:11|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  Again by default, the template will be re-rendered once the <<<clear>>> method returns.
  
  OfficeFloor achieves this simple interactive programming model by subsituting into the rendered page a unique url which it can map back to the corresponding method.  The method is matched by its name and is free to have any parameters it requires (enabled by OfficeFloor's dependency injection).  For example in more complex applications the handling methods may include a parameter for a <<<DataSource>>> or <<<EntityManager>>> to enable database interaction rather than just storing content into the object.  This however is beyond the scope of this tutorial.


* Controlling section rendering
  
  Now that the user is able to add and clear items, control is necessary to only render certain parts of the template.  
  
  In this case:
  
   * if there are items in the list, display them in a table
   
   * if there are no items in the list, provide a message indicating no items
   
  To provide control over the sections rendered in the page, the following interface is created.
  
%{code-snippet|brush-autodetect=1|id=flows|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  The interface is annotated to tell WoOF it provides flow links.  The methods of the interface correspond by name to the template sections and the template object's methods.  
  
  The template logic for controlling the rendering of sections is as follows:

%{code-snippet|brush-autodetect=1|id=control|sh-params=first-line:14|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}

  For the above methods, WoOF will invoke them before rendering the corresponding template sections.  On invoking the method, WoOF will generate an object implementing the <<<PageFlows>>> interface that will allow changing the next section to be rendered.  Should no method be invoked then the next section is rendered as per the template.  Should a method be invoked then the corresponding section by the interface method name becomes the next section to be rendered.  In this case:
  
   * For <<<getListItems>>> :
   
     * An empty items list will have rendering skip to the <<<getNoItems>>> method along with its corresponding section (skipping the rending of the table).
     
     * With items in the list, the flow interface method is not invoked so rendering will carry on to the next section (i.e. <<<listItems>>> template section).
     
   * For <<<getNoItems>>> :
   
     * Having items in the list will have rendering skip to the <<<endListItems>>> template section (skipping the rendering of the message).
     
     * An empty items list will cause the flow interface method to not be invoked so rendering will carry on to the next section (i.e. <<<noItems>>> template section).

  Controlling rendering of the template like this means that the code is not dependent on any framework API's and subsequently allows easier unit testing (via mocking the interface).
  
  This style of controlling the rendering works well with OfficeFloor's dependency injection.  As the methods match based on naming and not on method signature (i.e. parameters are ignored), it allows for the interface and template logic class methods to have different parameter lists.  The result is that dependencies are used only as necessary and also makes for adding/removing dependencies easier.  For example, the following shows the changes necessary to make a <<<DataSource>>> available:
    
%{code-snippet|brush-autodetect=1|id=extraDependency|file=${basedir}/src/main/java/net/officefloor/tutorial/pageflowhttpserver/TemplateLogic.java}
  
  OfficeFloor will happily inject the additional <<<DataSource>>> dependency on invoking the method.  The call from <<<getListItems>>> will not need to be aware that the implementing method has had a change in dependencies - especially if later it might change again to call a web service.
  
  This ability to dependency inject into methods is only the start of the functionality contained within OfficeFloor, as this starts to touch on the {{{/core/officeframe/job-based-architecture.html}Job Based Architecture}} at it's heart.


Unit Test

  The unit test requests the various URL's exposed from the template.

%{code-snippet|brush-autodetect=1|id=test|file=${basedir}/src/test/java/net/officefloor/tutorial/pageflowhttpserver/PageFlowHttpServerTest.java}


Next

  The {{{../NavigateHttpServer/index.html}next tutorial}} looks at navigating between pages (templates).
