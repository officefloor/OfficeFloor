                                               -----------------------
                                            Page Flow HTTP Server Example 
                                               -----------------------
					        Daniel Sagenschneider
                                               -----------------------

  <<Page Flow Http Server Example>>

  This example demonstrates controlling the flow of {{{/apidocs/net/officefloor/frame/api/execute/Task.html}Task}} executions into a {{{/apidocs/net/officefloor/frame/internal/structure/Flow.html}Flow}} to be able to:
  
   * rendering only parts of the template
   
   * user interaction with the web page (i.e. links and form submission)
   
   * maintaining state across requests (via HTTP session)
   
  Also touched on are some of OfficeFloor's dependency injection capabilities.
  
  The example will implement the ability to add items to a list along with clearing the list.  Different parts of the template will be shown based on whether there are items in the list.
  
Code

  The following is the <<<main>>> method to run the application.

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/PageFlowHttpServer.java}

  The above starts the HTTP Server with the dynamic template <<<Template.ofp>>> and a dependency injected object <<<Item>>> which is populated from form submission parameters.

* Template.ofp

  The below is the content of the template.

%{code-snippet|brush=xml|file=${basedir}/src/main/resources/Template.ofp}

  The <<< <!-- [name] --> >>> and <<< $\{name\} >>> respectively provide separation of the template into tasks and the ability to substitute java bean property values.  This example will use the template section divisions ( <<< <!-- [name] --> >>> ) to enable controlling what is rendered along with the <<< #\{name\} >>> (notice the # rather than $) for extending task execution to enable user interactions.

* TemplateLogic Class

  The <<<Template.ofp>>> has its logic provided by the <<<TemplateLogic>>> class.
  
  The first aspect of this class is the annotation to indicate that it should be bound to the HTTP Session.

%{code-snippet|brush-autodetect=1|id=class|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  The annotation is a flag to OfficeFloor that the <<<TemplateLogic>>> object for the page should be stored in the HTTP Session so that the list of items is subsequently stored across user requests.  The class implements <<<Serializable>>> as must all objects bound to a HTTP session.
  
  One reason why this is possible with OfficeFloor rather than other dependency injection containers is that OfficeFloor dependency injects into methods (i.e. via parameters) rather than the object itself (i.e. via fields).  Because of this objects within OfficeFloor do not need to hold reference to dependencies and subsequently can be made serialisable - something not easily possible with object dependency injection as dependencies are typically not serialisable.
  
  As the items are now stored across HTTP requests, they must be exposed for rendering the values to the template.  The below method via naming convention (prefixing the template section name <<< <!-- [items] --> >>> with <<<get>>>) exposes the <<<Item>>> objects for being rendered by that section (i.e. the <<< $\{name\} >>> and <<< $\{description\} >>>).

%{code-snippet|brush-autodetect=1|id=items|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  Initially there will be no items in the list so the page provides the form submission to add an item.  Looking back at the template you will notice that the action url is actually <<< #\{addItem\} >>> which corresponds to the following method via naming convention (same name).

%{code-snippet|brush-autodetect=1|id=addItem|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  Notice that the method has a single parameter <<< Item >>>.  Within the main method above the {{{/apidocs/net/officefloor/plugin/web/http/parameters/source/HttpParametersObjectManagedObjectSource.html}HttpParametersObjectManagedObjectSource}} configures it for dependency injection.  The result is that on invoking the <<< addItem >>> method, the following occurs:
  
   [[1]] <<< Item >>> dependency is instantiated from its default constructor
   
   [[1]] form submission parameters are reflectively loaded onto it
   
   [[1]] the <<< Item >>> object is passed to the invocation of the <<< addItem >>> method as the parameter value (what OfficeFloor refers to as dependency injection into methods)
   
  This relieves the developer of writing this code and allows them to focus on handling the values submitted by the user (in this case adding the item to the list).  It also makes for cleaner code.
  
  Once the <<< addItem >>> method returns, OfficeFloor will by default re-render the template back to the user.  It is possible to direct flow to other tasks however this is beyond the scope of this example.
  
  Along with adding an item to the list the template also provides the ability to clear the list of items.  In this case the template puts the <<< #\{clear\} >>> within a link which maps to the following method.

%{code-snippet|brush-autodetect=1|id=clear|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  Again by default, the template will be re-rendered once the <<< clear >>> method returns.
  
  OfficeFloor achieves this simple interactive programming model by subsituting into the rendered page a unique url which it can map back to the corresponding method.  The method is matched by its name and is free to have any parameters it requires (enabled by OfficeFloor's dependency injection into methods).  For example in more complex applications the handling methods may include a parameter for a <<< DataSource >>> or <<< EntityManager >>> to enable database interaction rather than just storing content into the object.  This however is beyond the scope of this example.

  Now that the user is able to add and clear items, control is necessary to only render certain parts of the template.  In this case:
  
   * if there are items in the list, display them in a table
   
   * if there are no items in the list, provide message indicating no items
   
  To provide control over the tasks rendering the page, the following interface is created.
  
%{code-snippet|brush-autodetect=1|id=flows|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  The interface is annotated to indicated it provides flow links and its methods correspond by name to template sections (and also other methods of the logic class).  The interface is then used for a parameter into the following methods to allow them control over rendering of the template. 

%{code-snippet|brush-autodetect=1|id=control|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}

  For the above methods, OfficeFloor will invoke them before rendering the corresponding template section.  On invoking the method, OfficeFloor will generate an object implementing the interface that will change the next task to be executed based on whether a method is invoked.  Should no method be invoked then the next task as per the template is executed.  Should however a method be invoked by the code then the corresponding task by the interface method name becomes the next task to execute.  In this case:
  
   * For <<< getListItems >>>:
   
     * An empty items list will have rendering skip to the <<< getNoItems >>> method task and subsequently the <<< noItems >>> template section task (skipping the rending of the table to display the items)
     
     * With items in the list no flow interface method is invoked so rendering will carry onto the next task which will be the <<< listItems >>> template section task
     
   * For <<< getNoItems >>>:
   
     * Having items in the list will have rendering skip to the <<< endListItems >>> template section task, skipping the rendering of the message indicating no items within the list.
     
     * An empty items list will cause no flow interface method to be invoked so rendering will carry on to the next task which will be the <<< noItems >>> template section task
     
  Controlling rendering of the template like this means that the code is not dependent on OfficeFloor API's and subsequently allows easier unit testing (via mocking the interface).

  Further to this is that with method dependency injection, the method being skipped to is likely to have parameters (dependencies) that the invoking method will not have.  In this case <<< getNoItems >>> does happen to have similar dependencies however later refactoring may see its functionality need a <<< DataSource >>> dependency. For example: 
  
%{code-snippet|brush-autodetect=1|id=extraDependency|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/TemplateLogic.java}
  
  OfficeFloor will happily inject the additional <<< DataSource >>> dependency on invoking the method with the client call (from <<< getListItems >>>) not aware that the method has had a change in dependencies.
  
  This ability to dependency inject into methods is only the start of the functionality contained within OfficeFloor as this starts to touch on the {{{/core/officeframe/job-based-architecture.html}Job Based Architecture}} at the heart of OfficeFloor.  This is also the means by which you can have different threads execute different methods (tasks) within your application.


* Remaining Classes

** Item Class

  As the Item is stored within the TemplateLogic object which is bound to the {{{/apidocs/net/officefloor/plugin/web/http/session/HttpSession.html}HttpSession}}, it must be serialisable. 

%{code-snippet|brush-autodetect=1|id=example|file=${basedir}/src/main/java/net/officefloor/example/pageflowhttpserver/Item.java}



Unit Test

  The unit test requests the various URL's exposed from the template.

%{code-snippet|brush-autodetect=1|id=test|file=${basedir}/src/test/java/net/officefloor/example/pageflowhttpserver/PageFlowHttpServerTest.java}

