options{    LOOKAHEAD= 1;    CHOICE_AMBIGUITY_CHECK = 2;    OTHER_AMBIGUITY_CHECK = 1;    STATIC = false;    DEBUG_PARSER = false;    DEBUG_LOOKAHEAD = false;    DEBUG_TOKEN_MANAGER = false;    ERROR_REPORTING = true;    JAVA_UNICODE_ESCAPE = false;    UNICODE_INPUT = false;    IGNORE_CASE = true;    USER_TOKEN_MANAGER = false;    USER_CHAR_STREAM = false;    BUILD_PARSER = true;    BUILD_TOKEN_MANAGER = true;    SANITY_CHECK = true;    FORCE_LA_CHECK = false;}PARSER_BEGIN(HttpTemplateParserImpl)package net.officefloor.plugin.web.http.template.parse;import java.util.List;import java.util.LinkedList;import java.io.IOException;/**
 * Implementation of {@link HttpTemplateParser}.
 *
 * @author Daniel Sagenschneider
 * @author javacc (many thanks to this wonderful tool)
 */public class HttpTemplateParserImpl implements HttpTemplateParser{    /**     * Default name for the first {@link HttpTemplateSection}.     */    public static final String DEFAULT_FIRST_SECTION_NAME = "template";    /**     * Listing of {@link HttpTemplateSection} instances.      */    private List < HttpTemplateSection > sections = new LinkedList < HttpTemplateSection > ();    /**	 * Current {@link HttpTemplateSection} name.	 */    private String currentSectionName = null;    /**	 * {@link NodeHttpTemplateSectionContent} for the {@link HttpTemplateSection}.	 */    private NodeHttpTemplateSectionContent currentSectionContents = new NodeHttpTemplateSectionContent("SECTION_BEAN", null);    /**	 * {@link NodeHttpTemplateSectionContent} for the current bean.	 */    private NodeHttpTemplateSectionContent currentBeanContents = this.currentSectionContents;    /**     * Current static HTML content.     */    private StringBuilder currentStaticContent = new StringBuilder();    /**	 * Current raw section content.	 */    private StringBuilder currentRawSectionContent = new StringBuilder();    /**     * {@link HttpTemplateParser} implementation.     */    public HttpTemplate parse() throws IOException    {        try        {            // Parse the template            this.parseTemplate();            // Complete the last section            this.completeCurrentSection();        }        catch (ParseException ex)        {            // Failed to parse template            throw new IOException(ex);        }        // Return the template        return new HttpTemplateImpl(this.sections.toArray(new HttpTemplateSection [this.sections.size()]));    }    /**	 * Adds a {@link HttpTemplateSection}.	 */    private void addSection(String sectionName)    {        // Complete the current section        this.completeCurrentSection();        // Parse out the comment, white spacing, brackets        sectionName = sectionName.substring("<!--".length(), (sectionName.length() - "-->".length()));        sectionName = sectionName.trim();        sectionName = sectionName.substring("{".length(), (sectionName.length() - "}".length()));        // Specify the new section name        this.currentSectionName = sectionName;    }    /**	 * Adds a {@link BeanHttpTemplateSectionContent} that is within a comment.	 */    public void addCommentBean(String beanName)    {        // Add the raw content        this.currentRawSectionContent.append(beanName);        // Parse out comment and white spacing        beanName = beanName.substring("<!--".length(), (beanName.length() - "-->".length()));        beanName = beanName.trim();        // Add the bean        this.addBean(beanName, true);    }    /**	 * Adds a {@link BeanHttpTemplateSectionContent}.	 */    private void addBean(String beanName, boolean isWithinComment)    {        // Add the raw content (if not within comment)        if (!isWithinComment)        {            this.currentRawSectionContent.append(beanName);        }        // Complete static content        this.completeStaticContent();        // Parse out bean bracket, white spacing        beanName = beanName.substring("${".length());        beanName = beanName.trim();        // Create the node content for the bean        NodeHttpTemplateSectionContent beanContent = new NodeHttpTemplateSectionContent(beanName, this.currentBeanContents);        // Add content and set as current bean        this.currentBeanContents.addContent(beanContent);        this.currentBeanContents = beanContent;    }    /**	 * Completes the current {@link BeanHttpTemplateSectionContent}.	 */    private void completeBean(Token token) throws ParseException    {        // Add the raw content        this.currentRawSectionContent.append(token);        // Complete static content        this.completeStaticContent();        // Move to parent bean        this.currentBeanContents = this.currentBeanContents.getParent();        // Ensure have parent        if (this.currentBeanContents == null)        {            throw new ParseException("No open Bean to close at line " + token.beginLine + " column " + token.beginColumn);        }    }    /**	 * Adds a {@link PropertyHttpTemplateSectionContent}.	 */    private void addProperty(String propertyName)    {        // Add the raw content        this.currentRawSectionContent.append(propertyName);        // Complete static content        this.completeStaticContent();        // Parse out property brackets        propertyName = propertyName.substring("${".length(), (propertyName.length() - "}".length()));        // Add the property        this.currentBeanContents.addContent(new NodeHttpTemplateSectionContent(new PropertyHttpTemplateSectionContentImpl(propertyName)));    }    /**	 * Adds a {@link LinkHttpTemplateSectionContent}.	 */    private void addLink(String linkName)    {        // Add the raw content        this.currentRawSectionContent.append(linkName);        // Complete static content        this.completeStaticContent();        // Parse out link brackets        linkName = linkName.substring("#{".length(), (linkName.length() - "}".length()));        // Add the link        this.currentBeanContents.addContent(new NodeHttpTemplateSectionContent(new LinkHttpTemplateSectionContentImpl(linkName)));    }    /**	 * Adds the static content for a {@link StaticHttpTemplateSectionContent}.	 */    private void addStaticContent(String staticContent)    {        // Add the raw content        this.currentRawSectionContent.append(staticContent);        // Add the static content        this.currentStaticContent.append(staticContent);    }    /**	 * Completes current {@link StaticHttpTemplateSectionContent}.	 */    private void completeStaticContent()    {        // Must have static content        String content = this.currentStaticContent.toString();        if (content.length() == 0)        {            return; // no static content        }        // Append the static content        this.currentBeanContents.addContent(new NodeHttpTemplateSectionContent(new StaticHttpTemplateSectionContentImpl(content)));        // Clear for next static content        this.currentStaticContent = new StringBuilder();    }    /**	 * Completes current {@link HttpTemplateSection}. 	 */    private void completeCurrentSection()    {        // Ensure content complete        this.completeStaticContent();        // Must have content for section        if (!this.currentSectionContents.isContent())        {            return; // no contents, so do not include section        }        // Obtain the current section name        String sectionName = (this.currentSectionName == null ? DEFAULT_FIRST_SECTION_NAME : this.currentSectionName);        // Obtain the contents and reset for next section        BeanHttpTemplateSectionContent sectionBean = (BeanHttpTemplateSectionContent) this.currentSectionContents.getHttpTemplateSectionContent();        HttpTemplateSectionContent [] sectionContents = sectionBean.getContent();        this.currentSectionContents = new NodeHttpTemplateSectionContent("SECTION_BEAN", null);        this.currentBeanContents = this.currentSectionContents;        // Create and add the section        HttpTemplateSection section = new HttpTemplateSectionImpl(sectionName, this.currentRawSectionContent.toString(), sectionContents);        this.sections.add(section);        // Reset for next section raw content        this.currentRawSectionContent = new StringBuilder();    }    /**	 * {@link HttpTemplateSectionContent} node within the parsing of the {@link HttpTemplateSection}.	 */    private static class NodeHttpTemplateSectionContent implements HttpTemplateSectionContent    {        /**         * Property name to obtain the bean.         */        private final String beanName;        /**		 * {@link HttpTemplateSectionContent} instances for the bean.		 */        private final List < NodeHttpTemplateSectionContent > contents;        /**		 * Parent {@link NodeHttpTemplateSectionContent}.		 */        private final NodeHttpTemplateSectionContent parent;        /**		 * Delegate {@link HttpTemplateSectionContent}.		 */        private final HttpTemplateSectionContent delegate;        /**		 * Initiate to be {@link BeanHttpTemplateSectionContent}.		 */        public NodeHttpTemplateSectionContent(String beanName, NodeHttpTemplateSectionContent parent)        {            this.beanName = beanName;            this.contents = new LinkedList < NodeHttpTemplateSectionContent > ();            this.parent = parent;            this.delegate = null;        }        /**		 * Initiate with delegate {@link HttpTemplateSectionContent}.		 */        public NodeHttpTemplateSectionContent(HttpTemplateSectionContent delegate)        {            this.beanName = null;            this.contents = null;            this.parent = null;            this.delegate = delegate;        }        /**		 * Adds a {@link NodeHttpTemplateSectionContent}.		 */        public void addContent(NodeHttpTemplateSectionContent content)        {            this.contents.add(content);        }        /**		 * Indicates if contains a {@link NodeHttpTemplateSectionContent}.		 */        public boolean isContent()        {            return (this.contents.size() > 0);        }        /**		 * Obtains the parent {@link NodeHttpTemplateSectionContent}.		 */        public NodeHttpTemplateSectionContent getParent()        {            return this.parent;        }        /**		 * Obtains the {@link HttpTemplateSectionContent}.		 */        public HttpTemplateSectionContent getHttpTemplateSectionContent()        {            // Determine if delegate content            if (this.delegate != null)            {                return this.delegate;            }            // As here it is a bean so generate the bean            HttpTemplateSectionContent [] beanContents = new HttpTemplateSectionContent [this.contents.size()];            for (int i = 0; i < beanContents.length; i++)            {                beanContents [i] = this.contents.get(i).getHttpTemplateSectionContent();            }            // Create and return the Bean content            BeanHttpTemplateSectionContent beanContent = new BeanHttpTemplateSectionContentImpl(this.beanName, beanContents);            return beanContent;        }    }}PARSER_END(HttpTemplateParserImpl)TOKEN :{    < LINK : "#{" < NAME > "}" >|   < PROPERTY : "${" < REFERENCE > "}" >|   < SECTION : "<!--" (< WHITE_SPACE >)* "{" < SECTION_NAME > "}" (< WHITE_SPACE >)* "-->" >|   < BEAN_COMMENT_OPEN : "<!--" (< WHITE_SPACE >)* < BEAN_OPEN > (< WHITE_SPACE >)* "-->" >|   < BEAN_COMMENT_CLOSE : "<!--" (< WHITE_SPACE >)* < BEAN_CLOSE > (< WHITE_SPACE >)* "-->" >|   < BEAN_OPEN : "${" < REFERENCE > (< WHITE_SPACE >)? >|   < BEAN_CLOSE : (< WHITE_SPACE >)? "$}" >|   < STATIC : ~[ ] >|   < #WHITE_SPACE : [ " ", "\t", "\n", "\r" ] >|   < #REFERENCE : < NAME > ("." < NAME >)* >|   < #SECTION_NAME :        (            (":")? < NAME >        )    |   "!" >|   < #NAME : [ "A"-"Z", "a"-"z" ] ([ "A"-"Z", "a"-"z", "0"-"9", "_" ])* >}/** * Parses the template. */void parseTemplate() :{}{    (        LOOKAHEAD(< SECTION >)        parseSection()    |   LOOKAHEAD(< BEAN_COMMENT_OPEN >)        parseBeanCommentOpen()    |   LOOKAHEAD(< BEAN_COMMENT_CLOSE >)        parseBeanCommentClose()    |   LOOKAHEAD(< BEAN_OPEN >)        parseBeanOpen()    |   LOOKAHEAD(< BEAN_CLOSE >)        parseBeanClose()    |   LOOKAHEAD(< PROPERTY >)        parseProperty()    |   LOOKAHEAD(< LINK >)        parseLink()    |   LOOKAHEAD(< STATIC >)        parseStaticContent()    )*    < EOF >}/** * Parses the section. */void parseSection() :{    Token t;}{    t = < SECTION >    {        this.addSection(t.image);    }}/** * Parses the bean open. */void parseBeanOpen() :{    Token t;}{    t = < BEAN_OPEN >    {        this.addBean(t.image, false);    }}/** * Parses the bean open. */void parseBeanCommentOpen() :{    Token t;}{    t = < BEAN_COMMENT_OPEN >    {        this.addCommentBean(t.image);    }}/** * Parses the bean close. */void parseBeanClose() :{    Token t;}{    t = < BEAN_CLOSE >    {        this.completeBean(t);    }}/** * Parses the bean close. */void parseBeanCommentClose() :{    Token t;}{    t = < BEAN_COMMENT_CLOSE >    {        this.completeBean(t);    }}/** * Parses the property. */void parseProperty() :{    Token t;}{    t = < PROPERTY >    {        this.addProperty(t.image);    }}/** * Parses the link. */void parseLink() :{    Token t;}{    t = < LINK >    {        this.addLink(t.image);    }}/** * Parses the static content. */void parseStaticContent() :{    Token t;}{    t = < STATIC >    {        this.addStaticContent(t.image);    }}