                                       -----------
                         Promoting good design vs policing a good design
                                       -----------
				   Daniel Sagenschneider
                                       -----------

Promoting good design vs policing a good design

  On a project with a small co-located existing team, the team can work as a harmonised unit to produce code that adheres to good design prinicples.  This is not to say that large distributed teams can not also produce similar results.  What is to say is the assumptions in a <small co-located existing> team:

   * <small co-located> means that everyone is likely to be communicating with each other and therefore have an understanding of all aspects of the project.

   * <existing> means that everyone on the team is over the learning curve and that the team will not lose members and have to train up new members.

  Over time however, projects grow and there is natural nutrition of members to teams.  Expecting everyone to know everything becomes more difficult.  Furthermore expecting everyone to adhere to architectures and designs by members possibly no longer on the project becomes even more difficult and overtime the project moves away from its origins.  This by no means is a bad thing and many methodologies expect this change as it is change to align with the requirements on the project.

  What becomes an issue is decisions being made without understanding the context in which the decision is being made.  It is all to easy to blame a developer for making a change that negatively impacts the system.  It is much harder to provide the necessary information to a developer to aid them in making good decisions.  Typically through budget constraints or even some methodologies the developer is given code files, some configuration files and with the aid of another developer who can only provide them limited time (as they themselves have functionality to deliver), the new developer is expected to make heads and tails of the system and then start producing functionality.

  What results is the developer making changes to the internals of the system and these changes require <policing> to ensure they align with the project's goals.  As information about a system is typically only in the code/configuration (other artifacts either stale or none existant) and there are tyipcally thousands of lines of code/configuration, the developer can only <realistically> pick up limited information about the system and therefore must make changes based on this information.  The developer therefore needs to be managed to ensure that the changes do not conflict with the goals of the project.

  In managing developers, the rate of change by developers makes management a potentially costly process.  Code reviews are important processes of any software development lifecycle, however reviewing code can be quite tedious due to the detail it encompasses.  It also encourages focus on <code style> rather than the underlying design principles that produce a well designed system.  The focus of good design starts getting lost to the detail that must be understood by everyone involved.

  Good design sees pasts the details of the code to the underlying principles of the system.  In architecting/designing systems it is typical to use some form of graphical tools to specify the various aspects of the system.  This allows discussion at various levels of abstraction about the architecture/design of systems without being caught up in the details of the code.

  
