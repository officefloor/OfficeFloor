                                       ---------------------------
                                         Graphical Configuration
                                       ---------------------------
                                          Daniel Sagenschneider
                                       ---------------------------

  <<{{{Graphical}Graphical Configuration}}>>

  OfficeFloor focuses on using graphical configuration to ease the complexities of software development and allow developers to get back to writing code rather than configuration (one of the principles behind OfficeFloor).



Background


* Components and configuration

  The focus on code re-use is creating components that are flexible to be re-used in different applications.  These components could range from being small libraries providing utility functions to large frameworks that govern how the application works.  Common between these components is that they expose interfaces (whether specific java types or <implied> signatures via reflection) that provide the ability to <interact> with the component.  To enable flexibility, typically these <interfaces> provide abstract, simpler access to the component's functionality with specific details of how the component is to operate contained in some form of <configuration>.  An example of this would be a logging component that only exposes methods on its interface to capture information to log and has its configuration specify where the information is to be logged (stored).

  The configuration of a component can become a <language> of its own.  To illustrate this point, take for example XML configuration.  The XML configuration will have a structure (possibly specified by an XML schema) that indicates how the elements are to be nested within each other and the attributes that the elements may contain.  To configure the component, an understanding of what each element and attribute represents is required.  This attached meaning to each XML element and attribute becomes a <language> by which to configure the component.

  The configuration <language> is additional knowledge that the developer/architects must learn.  In using the components, developers/architects will be required to configure the component so that is suitable for use in the application.  Should the developer/architect not be familiar with the configuration, they will be required to take the time to learn its specifics.  This can be a costly effort in terms of time as the configuration may:

   * not be completely documented requiring browsing of the component's code to get this understanding

   * have dependencies on providing other configuration that fails silently or with uninformative errors that leaves you <guessing> what is wrong

   * possibly not intuitive as the component focuses on functionality and flexibility and not so much on ease of configuring


* Managing configuration

  After the developer/architect has understood the configuration, the next issue that typically arrises is managing the configuration.  As the application grows in functionality, the configuration of many components also grow to aid in supporting that functionality.  In many cases configuration for a component is kept in a single file that ends up becoming an <uber> file of information.  The file contains all the details to configure the component and can grow to thousands of lines long.  This then creates such problems as:

   * too much detail that causes the developer significant effort to understand and subsequently make changes

   * merge conflicts as the configuration file becomes a central point that all developers require changing

   * fragil applications as small configuration changes can cause <unexpected> behaviour (typically because of lack of encapsulation in these large configuration files)


* Importance of configuration

  Configuration is as important as the code.  While many developers may like to focus on the writing code, the components they are using to build applications typically do not operate unless provided the necessary configuration.  Therefore to build and run the application, the developer's code, components and component configuration is required.  It is also not uncommon to have the configuration kept under the same source code repositories as the developer's code (possibly even side by side or even as annotation on the code itself).

  As the configuration is as important as the code, it should follow similar principles as code in being managed.  Some of these might include providing:

   * <encapsulation> of configuration.  In other words, exposing only certain information for an aspect of configuration to allow <easier> internal changes to that aspect

   * <modularising> configuration so that each 'module' is responsible for certain aspect of configuration.  This should allow developers some level of isolation in creating the configuration and also enable easier <code/configuration reviews> by their team leads.

   * <abstraction> of configuration.  This is not so much in the form on <inheritance> but more in the form of simplifying the detail of the configuration to be easier to understand

   * <'strong' validation> that acts similar to a compiler which can validate the configuration and the connections between the individual items in the configuration are valid.  This then for example is not just XML schema validation to ensure the XML structure is valid but validation that XML element content and relationships between that content are valid (much like a java compiler validating the arguments to a method are of the correct number and type).


* Configuration describes the application

  Frameworks are pushing more and more detail into configuration with developers only providing <snippets> of code where necessary.  The code developed by the developer is typically becoming small encapsulated functions/components that are <plugged> together by frameworks with details of how the functions/components are to be assembled contained in configuration.  These <snippets> of code become too smaller pieces to provide overview of the application which is now contained the configuration that joins these code <snippets> together.

  With the configuration containing significant details about the application and likely the important details of how the developer's code is managed, the configuration becomes the information that must be understood to obtain an overview of how the application works.  In using frameworks, developers will typically look for specific configuration files or sections of configuration files that contain <core> information on how the application is structured.

  Code will and always should be the developer's responsibility but should configuration only be readable by technical individuals?  There is likely always going to be the necessity for code to define the finer points of how an application functions, yet should configuration be represented in a similar fashion to code?  In other words, why does configuration have to have special syntax requiring technical skills to understand it?  If configuration contains the details of the application can these details be represented, so others who have other focuses other than the technical (usually the individuals from the business specifying the requirements for the application), also read the configuration? 

  Having the configuration readable by non-technical individuals means that additional effort by developers to explain or draw up diagrams explaining the application would be minimised.  The non-technical individuals would be able to review the configuration and provide feedback as to whether it is meeting their requirements.  If the configuration could also be editted in this fashion, the developer and non-technical individual (likely from the business providing the requirements) could sit together and use the configuration as visual aid to enable clear communication to validate the application.



{Graphical} Configuration

  Before discussion graphical configuration, the issues high lighted in the background are summarised below:

   * configuration needs to be intuitive

   * ability to <compile> configuration to ensure its validity

   * managing configuration similar to code (especially in encapsulation and modularising)

   * non-technical individuals should be able to read the configuration

  Of these issues, the one pushing most for graphical configuration is the ability for non-technical to be able to read the configuration.  As per the saying, "a picture speaks a thousand words", having the configuration graphical means that it will be much easier to understand than pages of text.  Development teams even use graphical representations through design and architecture diagrams that illustrate the functionality of an application and enable discussion around these diagrams.  Further to this, spotting errors in digrams is much easier than trying to spot errors in for example XML files.

  Graphical configuration also addresses the other issues above.  Developers are likely to get further with graphical editors than they would with say text editors.  Graphical configuration would also require modularising and encapsulating the configuration so that these <modules> can be graphically connected together.

  Graphical configuration would be required to represent the <underlying model> in the configuration and make this available in editors to manipulate.  In other words, the configuration can no longer be <free text> and must subsequently become an object model that graphical tools can edit (the M of MVC).  Though this puts structure around the configuration, it is possibly not too different as to the structure imposed by say XML schemas over XML configuration.

  As the configuration becomes a model, this model can be used as input to a compiler.  The model and the connections between the objects in this model can be validated by rules.  The model can also be transformed into other represenations.  This ability to validate and transform the model is similar to compilers validating source code and translating it into machine/byte code.

  In compiling the model, it enables the model to be modularised and encapsulated which results in <types>.  As the model is now being compiled, it is possible to use this compilation to validate the connection between separate pieces of configuration.  To enable this validation, each piece of configuration requires to be compiled into a type that can then be validated against the other configuration types it is being connected to.  As the types need only specify certain information about the configuration, this enables encapsulation of the configuration.

  Having graphical editors that configure models that can be compiled into types, leaves two questions open:

   * what is the model?

   * what are these types?

  OfficeFloor answers these questions by using a job based architecture.  The job based architecture defines an application as a listing of jobs that are executed by teams with each of these jobs requiring object dependencies.  From this architecture, the model can be extracted and from this the types derrived:

   * jobs which have inputs, outputs and object depenendencies (the information about the inputs, outputs and type of object dependencies required constitute the type) 

   * teams which execute the jobs (teams can be implemented many ways but have a similar type - they are assigned jobs to complete)

   * object dependencies (the type of object defines its type)

  This underlying model in the job based architecture provides the information for typing and subsequently compiling.  As the parts of the model can be compiled into types, graphical editors can then represent each part based on their types.  These parts can then be connected together by the graphical editor.

  As OfficeCompiler introduces additional types (<<<SectionSource>>>, <<<OfficeSource>>>, <<<OfficeFloorSource>>>) that focus on breaking down configuration into managable fragments only exposing the fragment's public information, this provides the modularising and encapsulation of configuration.  The actual content of the model compiled into the type is not required by the graphical editor, as the graphical editor only requires the public interface of the type to connect it to other types.  This does the following:

   * the underlying models to these types are free to be implemented as required (as long as they contain the necessary information to be compiled into a type)

   * the details of these models do not <clutter> the graphical editor and makes it easier for the developer to obtain the overview information

   * with a <quick> explanation of each type to a non-technical individual they should be able to follow the meaning of the graphical configuration and provide feedback on its correctness in terms of application requirements

  The flexibility of using the types in the graphical editors means that OfficeFloor can even import non-graphical configuration into its editors (with the caveate that a <<<Source>>> is written to compile the configuration into a type).

  Finally and possibly most importantly is OfficeFloor's principle of developers not <wasting> time writing configuration by hand.  Developers enjoy writing code and having developers spend large amounts of their time writing out hundreds/thousands of lines of configuration is taking them away from what they enjoy.

  OfficeFloor provides graphical configuration for its job based architecture so that developers can get back to the enjoyment of writing code rather than configuration.
