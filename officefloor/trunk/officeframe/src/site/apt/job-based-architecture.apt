                                           ------------------------
					    Job Based Architecture
                                           ------------------------
					    Daniel Sagenschneider
                                           ------------------------

  The {{{Job}Job Based Architecture}} focuses on defining the application as a list of jobs where each job type is assigned to a team to execute.  The architecture follows the natural blocks of code in structured programming and enhances this by allowing the various blocks of code (jobs) to be executed by the most appropriate thread (team).



Real world design pattern

  You need not look beyond the office (you are possibly sitting in right now) to see this design pattern in use.  Within an office there are various teams responsible for different jobs - eg sales for selling, billing for invoicing, IT to support systems.  Each team is specifically set up to handle their assigned jobs.

  The teams operate efficiently with each other to accomplish the work.  An example of this efficiency is interaction via email.  Should sales need a customer to be invoiced they can send off an email to billing requesting this and then get on with the other jobs at hand.  At some point later sales will receive email confirmation that the customer was invoiced.  The focal point of this interaction is that sales were able to accomplish other jobs while billing did the invoicing.  Sales did not spend their time hitting the refresh on their mail intently waiting for the invoice confirmation email.

  Sales hitting refresh waiting for the invoice confirmation email is typically what happens when <single servicing thread> design patterns such as <Thread per Request> are utilised.  As blocking operations (such as database and web service calls) tie up the thread, the thread sits idle waiting for a response and can not be used for other operations.  This causes necessity to increase the overall number of threads to cope with increasing load rather than follow the office design pattern and scale only the teams responsible for doing more jobs or bigger jobs.

  In essense, having to have a sales person doing billing means they are tied up from attending to customers and customers not being attended to is sales being lost.



Issues addressed by the job based architecture

  Issues addressed by the job based architecture are:

   * Limitations of single servicing thread architecture

   * Inversion of control, not just dependency injection


* Limitations of {single} servicing thread architecture

  To illustrate the limitations of the single servicing thread architecture, take for example the below sequential processing steps to service a web request:

+------------------------------------------------+
    try {

      // Code to parse the request

      // Code to handle request via retrieving content from a database

      // Code to generate response

      // Code to send response

    catch (Exception ex) {
      // Code to handle exception
    }
+------------------------------------------------+

  Following the single service thread architecture (typical of the <Thread per Request/Connection design pattern>), each step would be executed sequentially by a single thread responsible for servicing the request.  This works well and is the basis for most application servers. It however has the limitation that it ties up a thread to service the request and can become problematic with blocking operations (such as database calls).

  To illustrate the blocking operation issue with the single servicing thread architecture, let there for example be a large number of requests coming into the server (larger than the number of threads in the thread pool servicing requests).  In this situation, each thread is processing a single request and all remaining requests are queued waiting for a thread to become available.  Each queued request must wait until every request in front of it is has been passed to a thread before it itself gets serviced.  Should the queue of requests be significantly larger than the number of threads, the request may end up waiting for many requests in front of it to be completely serviced before it has even started to be processed.  The issue with the single servicing thread architecture is that it loses its efficiency as the majority of time the thread spends servicing a request is sleeping waiting for the network blocking calls to the database to return.  Requests are waiting for <sleepy workers> to get the job done.

  The queuing of requests in single servicing thread architecture becomes even more of a problem when requests are not all alike.  Take for example the following processing steps for servicing requests for a website's static home page and static images:

+------------------------------------------------+
    try {

      // Code to parse the request

      // Code to retrieve page/image from cache

      // Code to send response

    catch (Exception ex) {
      // Code to handle exception
    }
+------------------------------------------------+

  The above code to use a cached response will be significantly faster than the database network call response code.  Yet if the above described large number of requests are coming into the server, these smaller requests must also wait for the larger database requests in front of it in the queue to be finished before it is serviced.  This becomes a significant problem if the time to process these requests becomes time consuming to the point the user is not willing to wait for the home page and goes elsewhere - <the sales person busy with other work not attending to the customer problem>.

  The problem of a single servicing thread is not just restricted to web servers.  Architectures using queuing, SOA, batching and so forth are all likely to have blocking calls that require increasing overall thread counts to cope with increasing capacity.


* {Inversion} of control, not just dependency injection

  Dependency injection relies on a <Factory> to construct the inital object that requires all dependencies injected into it.  Typically this may be taken further by dependency injection solutions to provide frameworks that reduce the need for direct access to the <factories>.  It however does not address the need requiring <all> dependencies to be injected before the object can be used.

  To illustrate this take for example the following object (non-important code commented out):

+------------------------------------------------+
    public class InjectedObject {

        @resource
        private java.sql.Connection connection;

	@resource
	private Cache cache;

        public String getContent(String key) {
	    try {
	        // Attempt to obtain from cache
	        String content = this.cache.getContent(key);
	        if (content != null) {
	            return content;  // return content from cache
                }
		// Obtain content from database
		String content = this.getContentFromDatabase(key, this.connection);
		this.cache.storeContent(key, content);
		return content;
	    catch (Exception ex) {
	        // code to handle exception
	    }
	}

	private getContentFromDatabase(String key, java.sql.Connection connection) {
	    // code to retrieve database content
	}
    }
+------------------------------------------------+

  Before the above object can be used, it must be injected with both a <<<java.sql.Connection>>> and <<<Cache>>> dependency.  Should most content be available in the <<<Cache>>> the injection of a <<<java.sql.Connection>>> becomes unneeded processing, especially if the <<<java.sql.Connection>>> is retrieved from a connection pool causing both blocking to wait for an available <<<java.sql.Connection>>> and contention on the connection pool locks.

  It would be better to break the object into two so that retrieving content from <<<Cache>>> is not dependant on a <<<java.sql.Connection>>> also being made available.  Doing this would necessitate creating separate objects and subsequently <breaking> the interface of the client code.  Should separate threads be used for cache retrieval and database calls (as described by the issue of {{{single}single servicing thread architecture}}) the client becomes involved with the internal behaviour further breaking <encapsulation>.

  Note it is possible to inject a <<<javax.sql.DataSource>>> rather than <<<java.sql.Connection>>> to alleviate this problem, however doing so:

   * requires additional plumbing code to ensure the <<<java.sql.Connection>>> is closed (and possibly passed around to other functionality involved in the transaction on the <<<java.sql.Connection>>>)

   * still suffers blocking waiting for the <<<java.sql.Connection>>> when one is required

  To summarise, just using dependency injection has limitations and the following enhancements are necessary to improve its efficiency:

   * Only the necessary dependencies are injected for each block of code

   * Dependencies are ready to use on injecting



{Job} based architecture

  The job based architecture focuses on providing the following:

   * Ability to select the thread responsible for executing each block of code

   * Only the necessary dependencies are injected for each block of code

   * Dependencies are ready to use on injecting

  Along with the above focuses, there are two additional focuses that have been implied by using blocks of code:

   * Output of a block of code may be input to the next block of code

   * Not all blocks of code are sequential one after another.  <<<if>>> statements and <<<catch>>> blocks can cause different blocks of code to be executed

  The following diagram illustrates each of these focuses providing an overview of the job based architecture:

[images/JobBasedArchitectureOverview.png] Job Based Architecture Overview

  To better explain the job based architecture, let's go back to the example of obtaining content for a web request in the {{{Inversion}Inversion of control}} section.  Further to this we will use the <<<ClassWorkSource>>> plug-in to OfficeFloor that allows reflectively invoking methods as <blocks of code> (jobs).

  The example <<<getContent>>> method will be broken down into the following blocks of code:

   [[1]] Obtain content from cache

   [[2]] Obtain content from database

   [[3]] Store database content to cache

   [[4]] Catch block to handle exceptions

  The blocks of code will be joined together into the following flow:

[images/JobBasedArchitectureExample.png] Job Based Architecture Example


* Obtain content from cache

  The following object handles the job of obtaining content from cache.  The class jumps straight into the depths of the <<<ClassWorkSource>>> which uses reflection on POJOs to obtain the blocks of code to be executed and is provided with the Office Compiler (you may however elect to write your own <<<WorkSource>>>, more detail can be found under Office Compiler).  The <<<[?]>>> on the left are markers for further explanation below.

+------------------------------------------------+
        public class CacheFunctions {

[1]         public String getContent(String key, Cache cache, GetContentFlows flows) {
	        String content = cache.getContent(key);
	        if (content != null) {
[2]                 return content; // content available from cache
                }
[3]	        flows.doGetNonCachedContent(key);
	        return null;  // ignored as alternate flow will retrieve data
	    }

	    @FlowInterface
[4]	    public static interface GetContentFlows {
	        void doGetNonCachedContent(String key);
	    }
        }
+------------------------------------------------+

  <<<[1]>>> Is the method signature identifying the necessary inputs to the <<<getContents>>> block of code (job).  It requires a <<<key>>> which is likely the output of the previous block of code, <<<Cache>>> which is dependency injected and <<<GetContentFlows>>> (see <<<[4]>>>).  The <<<ClassWorkSource>>> uses reflection to extract this information from the class so that the developer need only write POJOs.

  <<<[2]>>> Returns the content as output for the next block of code to use.

  <<<[3]>>> The content was not cached so an alternate block of code is invoked to obtain the content.  As the class name suggests, this object is only responsible for cached content so should not dictate how non-cached content is retrieved.  It therefore passes flow control onto an alternate block of code which becomes responsible for retrieving the content.  The return is <<<null>>> as the alternate block of code will return the retrieved content.

  <<<[4]>>> This POJO interface provides <<<ClassWorkSource>>> the alternate flows that may be invoked by <<<getContent>>>.  <<<ClassWorkSource>>> will generate a <<<Proxy>>> object implementing the interface that delegates to Office Frame to invoke the flow (allows the developer to invoke <typed> methods to trigger alternate flows, rather than the open Office Frame method <<<doFlow(int flowIndex, Object parameter)>>>).  The annotation <<<@FlowInterface>>> flags for <<<ClassWorkSource>>> to provide the <<<Proxy>>>.


* Obtain content from {database}

  The following object handles the job of obtaining content from the database.  This class again uses the <<<ClassWorkSource>>> to enable use of POJOs.

+------------------------------------------------+
    public class DatabaseFunctions {

	public KeyedData getDatabaseContent(String key, Connection connection) throws SQLException {
	    PreparedStatement statement = connection.prepareStatement("SELECT CONTENT FROM CONTENT_TABLE WHERE KEY = ?");
            statement.setString(1, key);
	    ResultSet resultSet = statement.executeQuery();
	    resultSet.next(); // for simplicity always assume data (may use alternate flow to handle case of no data)
	    String content = resultSet.getString("CONTENT");
	    statement.close();
	    return new KeyedData(key, content);
	}
    }
+------------------------------------------------+

  The <<<KeyedData>>> is an object to allow associating content with its key: 

+------------------------------------------------+
    public class KeyedData {
	public final String key;
	public final String content;
	public KeyedData(String key, String content) {
	    this.key = key;
	    this.content = content;
	}
    }
+------------------------------------------------+

  The <<<DatabaseFunctions>>> class provides a <simple> database retrieval block of code to obtain content from table <<<CONTENT_TABLE>>> in the database.  The method is invoked as a result of the alternate flow (<<<doGetNonCachedContent>>>) being invoked from <<<getContent>>>.  The <<<key>>> was passed as the argument to the <<<doGetNonCacheContent>>> method, while the <<<Connection>>> is dependency injected.

  Note that a proper implementation would include alternate flows to handle not obtaining content from the database.  The <<<SQLException>>> however is left to be thrown as Office Frame provides the ability to catch these exceptions and delegate them to another {{{Catch}block of code (job)}} to handle.


* Store database content to cache

  Once content is retrieved from the database, it should be cached so that further requests for the content will be available in the cache.  As caching is not the responsibility of the database code, the method will be added to the <<<CacheFunctions>>> class.

+------------------------------------------------+
    public class CacheFunctions {

        // getContent code ommitted

	public String cacheContent(KeyedData data, Cache cache) {
	    cache.storeContent(data.key, data.content);
	    return data.content;
	}
    }
+------------------------------------------------+

  The <<<cacheContent>>> method is invoked with the <<<KeyedData>>> returned from the <<<getDatabaseContent>>> and the <<<Cache>>> dependency injected.  The method stores the content into the <<<Cache>>> and then returns the content so that the next block of code (job) may be the same as the next block of code (job) for the <<<getContent>>> method.  In other words, this results in the following <<<if>>> statement (except that blocks of code reference only dependencies they require and the thread executing each block of code may be different):

+------------------------------------------------+
    get content from cache
    if content not in cache
        get from content from database
	store content to cache
    end if
    use content
+------------------------------------------------+

  The resulting <<<useContent>>> method then may have, for example, the following method signature:

+------------------------------------------------+
    public OutputForNextJob useContent(String content, Writer writer) throws IOException
+------------------------------------------------+

  where the <<<useContent>>> will possibly write the content to a <<<Writer>>> that results in sending the content to the HTTP client.


* {Catch} block to handle exceptions

  The {{{database}obtain content from database}} method throws an <<<SQLException>>> which requires to be handled.  As the handling of an exception (typically know as an <Escalation> within OfficeFloor) may require a different thread, different dependencies and its own alternate flows, the handling code itself becomes another block of code (a <catch> block of code).

  An example catch block of code for the <<<getDatabaseContent>>> may be as follows:

+------------------------------------------------+
    public void handleException(SQLException escalation, Writer writer) {
        writer.write(escalation.getMessage());
    }
+------------------------------------------------+

  This simple example would write the message of the exception to a <<<Writer>>> which may send this back to the HTTP client.

  More complex handing of exceptions (escalations), could for example:

   * log failure

   * provide more <user friendly> web page for the error

   * send alerts

   * redirect HTTP client to another web server as this web server is currently having connection issues to database

  As the <<<catch block of code>>> is a separate block of code, it provides the following advantages:

   * decisions about how to appropriately handle exception (escalations) can be made later with possible input from project leads and the business

   * decisions about how to handle exceptions can be changed without code changes

   * new types of exceptions occuring due to code changes do not need to be handled by calling code (for example if non-cached content was to be retrieved from a Web Service rather than a database the exception thrown could change from <<<java.sql.SQLException>>> to a <<<web.service.WebServiceException>>>).  It also encourages developers to use informative method signatures in their code rather than being tempted to use non-checked exceptions

   * exception handling code does not <clutter> the main flows


* Threading (teams)

  As each of the above methods is wrapped as a <Job> by the <<<ClassWorkSource>>> the job based architecture is free to invoke each method with a different thread (team).  The exact configuration of which thread to invoke which method can be left until application assembly and deployment time - allowing the application to be tuned to the hardware it is running on.


* Dependency Injection and asynchronous operations

  Dependencies (known as <<<ManagedObjects>>> within OfficeFloor) are managed by a job based architecture so that on invoking the job (block of code) the dependencies are ready for use.  Typically database calls are blocking and the job based architecture need only provide a valid <<<java.sql.Connection>>> to the job.  For other operations, such as calling web services with nio, the job is post-poned from being executed until the web service call returns (or times out) allowing the thread to do other work in the mean time.  An example would be:

+------------------------------------------------+
    public class WebServiceCaller {
    
        public void callWebService(String url, WebServiceCaller caller) {
	    caller.invokeAsyncCall(url);
	}
	
	// job based architecture will hold off calling next method until the WebServiceCaller's asynchronous call has returned
	
	public String getWebServiceResponse(WebServiceCaller caller) {
	    return caller.getResponse();
	}
    }
+------------------------------------------------+



Using a Job Based Architecture

  Simplify the application into blocks of code (jobs) means that these blocks of code must be connected together to create the execution flows of an application.  Manually connecting them together by the developer, either through additional plumbing code or hand written configuration, is error prone and likely very time consuming for the developer.  Therefore having a job based architecture, though improviing the efficiency of applications, needs additional tools to aid in the efficiency of rapid application development and developer learning curves.

  Graphical configuration of connecting the blocks of code together into a flow is necessary to improve efficiency of development.  As the blocks of code provide meta-data about their inputs and outputs, graphical tools are used to connect them together removing the need for developers to write out the configuration by hand.  As the flows in the application are represented graphically, it is also much easier for developers to review these to get an understanding of the system.  The graphical reprsentation even enables non-technical individuals to review aspects of the system.

  OfficeFloor provides both the job based architecture and graphical tools.

